

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>resistics.utilities.utilsRobust &mdash; resistics 0.0.6.dev2 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> resistics
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conventions.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../formats.html">Data formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cookbook.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../case-studies.html">Case studies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../donate.html">Donate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">resistics</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>resistics.utilities.utilsRobust</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for resistics.utilities.utilsRobust</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The source for these functions is Robust Statisitics, Huber, 2009</span>
<span class="sd">in general, linear regression is# have observations y and predictors A</span>
<span class="sd">y is multiple observations/response</span>
<span class="sd">x are the independent variables and is unknown</span>
<span class="sd">and y is a linear function of x =&gt; y = Ax</span>
<span class="sd">y = nobs</span>
<span class="sd">A = nobs * nregressors</span>
<span class="sd">x = nregressors</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">linalg</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="c1"># import from package</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsChecks</span> <span class="k">import</span> <span class="n">parseKeywords</span>


<div class="viewcode-block" id="mmestimateModel"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.mmestimateModel">[docs]</a><span class="k">def</span> <span class="nf">mmestimateModel</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;2 stage M estimate</span>

<span class="sd">    Solves for :math:`x` where,</span>

<span class="sd">    .. math::        </span>
<span class="sd">        y = Ax .</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray</span>
<span class="sd">        Predictors, size nobs*nregressors</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        Observations, size nobs</span>
<span class="sd">    initial : Dict</span>
<span class="sd">        Initial solution with parameters, scale and residuals</span>
<span class="sd">    scale : optional</span>
<span class="sd">        A scale estimate</span>
<span class="sd">    intercept : bool, optional</span>
<span class="sd">        True or False for adding an intercept term</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : np.ndarray</span>
<span class="sd">        Values in x</span>
<span class="sd">    resids : np.ndarray</span>
<span class="sd">        Residuals = y - Ax</span>
<span class="sd">    scale : float</span>
<span class="sd">        Robust measure of variance</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        Weights used in robust regression   </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">defaultDictionary</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">printkw</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">intercept</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span>
    <span class="c1"># this uses an initial mestimate with huber to give a measure of scale</span>
    <span class="c1"># and then a second with bisquare or hampel weights</span>
    <span class="k">if</span> <span class="s2">&quot;initial&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;scale&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">][</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">][</span><span class="s2">&quot;resids&quot;</span><span class="p">])</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;huber&quot;</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="n">intercept</span>
        <span class="p">)</span>
        <span class="c1"># now do another, but with a different weighting function</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">][</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="c1"># kwargs[&quot;initial&quot;][&quot;params&quot;] = params # put the new solution in, because simply then doing bisquare, which has zero weights, might mess things up</span>
        <span class="c1"># kwargs[&quot;initial&quot;][&quot;resids&quot;] = resids</span>
        <span class="n">params2</span><span class="p">,</span> <span class="n">resids2</span><span class="p">,</span> <span class="n">scale2</span><span class="p">,</span> <span class="n">weights2</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;bisquare&quot;</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="n">intercept</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;huber&quot;</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="n">intercept</span>
        <span class="p">)</span>
        <span class="c1"># now do another, but with a different weighting function</span>
        <span class="n">params2</span><span class="p">,</span> <span class="n">resids2</span><span class="p">,</span> <span class="n">scale2</span><span class="p">,</span> <span class="n">weights2</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;bisquare&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="n">intercept</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">params2</span><span class="p">,</span> <span class="n">resids2</span><span class="p">,</span> <span class="n">scale2</span><span class="p">,</span> <span class="n">weights2</span></div>


<div class="viewcode-block" id="mestimateModel"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.mestimateModel">[docs]</a><span class="k">def</span> <span class="nf">mestimateModel</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Mestimate robust least squares</span>

<span class="sd">    Solves for :math:`x` where,</span>

<span class="sd">    .. math::        </span>
<span class="sd">        y = Ax .</span>

<span class="sd">    Good method for dependent outliers (in :math:`y`). Not robust against independent outliers (leverage points)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray</span>
<span class="sd">        Predictors, size nobs*nregressors</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        Observations, size nobs</span>
<span class="sd">    initial : </span>
<span class="sd">    scale : optional</span>
<span class="sd">        A scale estimate</span>
<span class="sd">    intercept : bool, optional</span>
<span class="sd">        True or False for adding an intercept term</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : np.ndarray</span>
<span class="sd">        Values in x</span>
<span class="sd">    resids : np.ndarray</span>
<span class="sd">        Residuals = y - Ax</span>
<span class="sd">    scale : float</span>
<span class="sd">        Robust measure of variance</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        Weights used in robust regression    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">defaultDictionary</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">printkw</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># calculate the leverage</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pnRatio</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">n</span>

    <span class="c1"># calculate the projection matrix</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">Pdiag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">del</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">Pdiag</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="n">leverageScale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="n">leverageWeights</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span>
        <span class="n">Pdiag</span> <span class="o">/</span> <span class="n">leverageScale</span><span class="p">,</span> <span class="s2">&quot;huber&quot;</span>
    <span class="p">)</span>  <span class="c1"># this should nowhere be equal to zero because of the previous line</span>

    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># add column of ones for constant term</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">A</span><span class="p">))</span>

    <span class="c1"># see whether to do an initial OLS model or whether one is provided</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">initialFromDict</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">olsModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">resids</span><span class="p">)</span>

    <span class="c1"># if an initial model was not provided but an initial scale was, replace the one here</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span>

    <span class="c1"># standardised residuals and weights</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">resids</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">leverageWeights</span>
    <span class="p">)</span>

    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="c1"># standardise and calculate weights</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">])</span>
            <span class="o">*</span> <span class="n">leverageWeights</span>
        <span class="p">)</span>
        <span class="c1"># increment iteration and save weightsNew</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="c1"># check to see whether the change is smaller than the tolerance</span>
        <span class="c1"># use the R method of checking change in residuals (can check change in params)</span>
        <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># update residuals</span>
            <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
            <span class="k">break</span>
        <span class="c1"># update residuals</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="olsModel"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.olsModel">[docs]</a><span class="k">def</span> <span class="nf">olsModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Ordinary least squares</span>

<span class="sd">    Solves for :math:`x` where,</span>

<span class="sd">    .. math::       </span>
<span class="sd">        y = Ax .</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray</span>
<span class="sd">        Predictors, size nobs*nregressors</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        Observations, size nobs</span>
<span class="sd">    intercept : bool, optional</span>
<span class="sd">        True or False for adding an intercept term</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : np.ndarray</span>
<span class="sd">        Least squares solution</span>
<span class="sd">    resids : np.ndarray</span>
<span class="sd">        Residuals</span>
<span class="sd">    squareResid : np.ndarray</span>
<span class="sd">        Square residuals</span>
<span class="sd">    rank : int</span>
<span class="sd">        Rank of matrix A</span>
<span class="sd">    s : np.ndarray</span>
<span class="sd">        Singular values of A</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">defaultDictionary</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">printkw</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]:</span>
        <span class="c1"># add a constant term for the intercept</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">A</span><span class="p">))</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">resids</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span></div>


<div class="viewcode-block" id="chatterjeeMachler"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.chatterjeeMachler">[docs]</a><span class="k">def</span> <span class="nf">chatterjeeMachler</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Robust bounded influence solver</span>
<span class="sd">    </span>
<span class="sd">    Solves for :math:`x` where,</span>

<span class="sd">    .. math::  </span>
<span class="sd">        y = Ax .</span>

<span class="sd">    Being a bounded influence operator, should be robust against both outliers in dependent and independent variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray</span>
<span class="sd">        Predictors, size nobs*nregressors</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        Observations, size nobs</span>
<span class="sd">    intercept : bool, optional</span>
<span class="sd">        True or False for adding an intercept term</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : np.ndarray</span>
<span class="sd">        Values in x</span>
<span class="sd">    resids : np.ndarray</span>
<span class="sd">        Residuals = y - Ax</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        Weights used in robust regression     </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">defaultDictionary</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">printkw</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># generalPrint(&quot;S-Estimate&quot;, &quot;Using weight function = {}&quot;.format(weightFnc))</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># add column of ones for constant term</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">A</span><span class="p">))</span>

    <span class="c1"># now calculate p and n</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pnRatio</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">n</span>

    <span class="c1"># calculate the projection matrix</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">Pdiag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">del</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span>
    <span class="c1"># and save an array for later</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">Pdiag</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="n">weightsNom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">Pdiag</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># weights for the first iteration</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pnRatio</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">weights</span>
        <span class="n">residsAbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="n">residsMedian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">residsAbs</span><span class="p">)</span>
        <span class="c1"># now compute the new weights</span>
        <span class="n">weightsDenom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">residsAbs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">residsMedian</span>
        <span class="p">)</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="n">weightsNom</span> <span class="o">/</span> <span class="n">weightsDenom</span>

        <span class="c1"># increment iteration</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check to see whether the change is smaller than the tolerance</span>
            <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
                <span class="c1"># update resids</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
                <span class="k">break</span>
        <span class="c1"># update resids</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="chatterjeeMachlerMod"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.chatterjeeMachlerMod">[docs]</a><span class="k">def</span> <span class="nf">chatterjeeMachlerMod</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># using the weights in chaterjeeMachler means that min resids val in median(resids)</span>
    <span class="c1"># instead, use M estimate weights with a modified residual which includes a measure of leverage</span>
    <span class="c1"># for this, use residuals / (1-p)^2</span>
    <span class="c1"># I wonder if this will have a divide by zero bug</span>

    <span class="c1"># now calculate p and n</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pnRatio</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">n</span>

    <span class="c1"># calculate the projection matrix</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">Pdiag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">del</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">Pdiag</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.0000000001</span><span class="p">)</span>
    <span class="n">locP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="n">scaleP</span> <span class="o">=</span> <span class="n">sampleMAD</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="c1"># bound = locP + 6*scaleP</span>
    <span class="n">bound</span> <span class="o">=</span> <span class="n">locP</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">scaleP</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Pdiag</span> <span class="o">&gt;</span> <span class="n">bound</span><span class="p">)</span>
    <span class="n">Pdiag</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99999</span>
    <span class="n">leverageMeas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">Pdiag</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># weights for the first iteration</span>
    <span class="c1"># this is purely based on the leverage</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pnRatio</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

    <span class="c1"># get options</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">defaultDictionary</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">printkw</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># generalPrint(&quot;S-Estimate&quot;, &quot;Using weight function = {}&quot;.format(weightFnc))</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># add column of ones for constant term</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">A</span><span class="p">))</span>

    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">weights</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsNew</span> <span class="o">/</span> <span class="n">leverageMeas</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>

        <span class="c1"># standardise and calculate weights</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsNew</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">residsNew</span><span class="p">,</span> <span class="s2">&quot;huber&quot;</span><span class="p">)</span>
        <span class="c1"># increment iteration</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check to see whether the change is smaller than the tolerance</span>
            <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
                <span class="c1"># update resids</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
                <span class="k">break</span>
        <span class="c1"># update resids</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>

    <span class="c1"># now do the same again, but with a different function</span>
    <span class="c1"># do the least squares solution</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">olsModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">resids</span> <span class="o">=</span> <span class="n">resids</span> <span class="o">/</span> <span class="n">leverageMeas</span>
    <span class="n">resids</span> <span class="o">=</span> <span class="n">resids</span> <span class="o">/</span> <span class="n">scale</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="s2">&quot;trimmedMean&quot;</span><span class="p">)</span>
    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">weights</span>

        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsNew</span> <span class="o">/</span> <span class="n">leverageMeas</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>

        <span class="c1"># standardise and calculate weights</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsNew</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">residsNew</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">])</span>
        <span class="c1"># increment iteration</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="c1"># check to see whether the change is smaller than the tolerance</span>
        <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># update resids</span>
            <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
            <span class="k">break</span>
        <span class="c1"># update resids</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>

    <span class="c1"># at the end, return the components</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="chatterjeeMachlerHadi"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.chatterjeeMachlerHadi">[docs]</a><span class="k">def</span> <span class="nf">chatterjeeMachlerHadi</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Regression based on Hadi distances</span>



<span class="sd">    # Another regression method based on Hadi distances</span>
<span class="sd">    # implemented from the paper A Re-Weighted Least Squares Method for Robust Regression Estimation</span>
<span class="sd">    # Billor, Hadi    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># basic info</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">defaultDictionary</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">printkw</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># for the distances, will use absX - do this before adding intercept term</span>
    <span class="c1"># a column of all ones will cause problems with non full rank covariance matrices</span>
    <span class="n">absX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="c1"># now calculate p and n</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">absX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">absX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># we treat the X matrix as a multivariate matrix with n observations and p variables</span>
    <span class="c1"># first need to find a basic subset free of outliers</span>
    <span class="n">correctionFactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">chi</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">chi2bound</span> <span class="o">=</span> <span class="n">correctionFactor</span> <span class="o">*</span> <span class="n">chi</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    <span class="c1"># calculate h, this is the size of the firt basic subset</span>
    <span class="c1"># note that this is the value h, the index of the hth element is h-1</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># here, only want the integer part of this</span>
    <span class="c1"># need to get the coordinatewise medians - this is the median of the columns</span>
    <span class="n">medians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">absX</span><span class="p">)</span>
    <span class="c1"># now compute the matrix to help calculate the distance</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">absX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">medians</span>
        <span class="n">A</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span>

    <span class="c1"># now calculate initial distances</span>
    <span class="n">dInit</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">medians</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

    <span class="c1"># now get the h smallest values of d</span>
    <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dInit</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">sortOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">h</span><span class="p">]</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span>
        <span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>  <span class="c1"># observations in rows, columns are variables</span>
    <span class="n">dH</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>

    <span class="c1"># rearrange into n observations into order and partition into two initial subsets</span>
    <span class="c1"># one subset p+1, the n-p-1</span>
    <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dH</span><span class="p">)</span>
    <span class="n">indicesBasic</span> <span class="o">=</span> <span class="n">sortOrder</span><span class="p">[:</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1"># there is a rank issue here, but ignore for now - natural observations will presumably be full rank</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indicesBasic</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indicesBasic</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>

    <span class="c1"># create the basic subset</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
    <span class="k">if</span> <span class="n">increment</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># here, limiting to 100 iterations of this</span>
    <span class="k">while</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">:</span>
        <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">sortOrder</span><span class="p">[:</span><span class="n">r</span><span class="p">]</span>  <span class="c1"># indices start from zero, hence the - 1</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">increment</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="n">increment</span>

    <span class="c1"># now the second part = add more points and exclude outliers to basic set</span>
    <span class="c1"># all distances above r+1 = outliers</span>
    <span class="c1"># r = p + 1</span>
    <span class="c1"># increment = (n - 1 - r)/100</span>
    <span class="k">while</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">dist2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist2</span><span class="p">[</span><span class="n">sortOrder</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">chi2bound</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c1"># then leave, everything else is an outlier - it would be good if this could be saved somehow</span>
        <span class="c1"># otherwise, continue adding points</span>
        <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">sortOrder</span><span class="p">[:</span><span class="n">r</span><span class="p">]</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">increment</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="n">increment</span>

    <span class="c1"># now with the Hadi distances calculated, can proceed to do the robust regression</span>
    <span class="c1"># normalise and manipulate Hadi distances</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="c1"># for the median, use the basic subset</span>
    <span class="c1"># indicesBasic = sortOrder[:r]</span>
    <span class="c1"># distMedian = np.median(dist[indicesBasic]) # I am using on indicesBasic</span>
    <span class="n">distMedian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>  <span class="c1"># the paper suggests using the median of the complete</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">distMedian</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">dist2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist2</span><span class="p">)</span>

    <span class="c1"># calculate first set of weights - this is simply dist</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">dist</span>

    <span class="c1"># now add the additional constant intercept column if required</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># add column of ones for constant term</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">X</span><span class="p">))</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">weights</span>

        <span class="n">residsAbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="n">residsSquare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">residsAbs</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsSquare</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">residsSquare</span><span class="p">)</span>
        <span class="n">residsMedian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">residsAbs</span><span class="p">)</span>

        <span class="c1"># calculate the new weights</span>
        <span class="n">tmpDenom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">residsNew</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">residsMedian</span>
        <span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">tmpDenom</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># increment iteration</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check to see whether the change is smaller than the tolerance</span>
            <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
                <span class="c1"># update resids</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
                <span class="k">break</span>
        <span class="c1"># update resids</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>

    <span class="c1"># at the end, return the components</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="calculateDistCMH"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.calculateDistCMH">[docs]</a><span class="k">def</span> <span class="nf">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">):</span>
    <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">mean</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">dist</span></div>


<div class="viewcode-block" id="weightLS"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.weightLS">[docs]</a><span class="k">def</span> <span class="nf">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transform A and y using the weights to perform a weighted least squares</span>

<span class="sd">    .. math::</span>
<span class="sd">        \sqrt{weights} y = \sqrt{weights} A x ,</span>
<span class="sd">    </span>
<span class="sd">    is equivalent to,</span>
<span class="sd">    </span>
<span class="sd">    .. math::     </span>
<span class="sd">        A^H weights y = A^H weights A x ,</span>
<span class="sd">    </span>
<span class="sd">    where :math:`A^H` is the hermitian transpose.</span>

<span class="sd">    In this method, both y and A are multipled by the square root of the weights and then returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        Observations</span>
<span class="sd">    A : np.ndarray</span>
<span class="sd">        Regressors</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        Observations multipled by the square root of the weights</span>
<span class="sd">    A : np.ndarray</span>
<span class="sd">        Regressors multipled by the square root of the weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>
    <span class="n">Anew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">Anew</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span></div>


<div class="viewcode-block" id="hermitianTranspose"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.hermitianTranspose">[docs]</a><span class="k">def</span> <span class="nf">hermitianTranspose</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Hermitian transpose (transpose and complex conjugation)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Vector, matrix to Hermitian transpose</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Hermitian transpose</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span></div>


<div class="viewcode-block" id="initialFromDict"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.initialFromDict">[docs]</a><span class="k">def</span> <span class="nf">initialFromDict</span><span class="p">(</span><span class="n">initDict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns initial model from provided initial model dictionary</span>
<span class="sd">    </span>
<span class="sd">    Helps for two stage robust regression.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Dict</span>
<span class="sd">        Initial model to use for robust regression with the parameters, residuals and scale estimate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    parameters : np.ndarray</span>
<span class="sd">        </span>
<span class="sd">    resids : np.ndarray</span>
<span class="sd">        The residuals</span>
<span class="sd">    scale : float</span>
<span class="sd">        Initial estimate of scale</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">initDict</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> <span class="n">initDict</span><span class="p">[</span><span class="s2">&quot;resids&quot;</span><span class="p">],</span> <span class="n">initDict</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="defaultDictionary"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.defaultDictionary">[docs]</a><span class="k">def</span> <span class="nf">defaultDictionary</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Robust regression defaults</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict</span>
<span class="sd">        Default regression options</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">outDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bisquare&quot;</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxIter</span><span class="p">()</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">outDict</span></div>


<div class="viewcode-block" id="getRobustLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.getRobustLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">getRobustLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Robust weighting schemes</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.ndarray</span>
<span class="sd">        Residuals</span>
<span class="sd">    weight : str</span>
<span class="sd">        The type of weighting to use</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        The robust weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the second argument, k, is a tuning constant</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;huber&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mf">1.345</span>
        <span class="c1"># k = 0.5</span>
        <span class="k">return</span> <span class="n">huberLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;hampel&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">return</span> <span class="n">hampelLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;trimmedMean&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">trimmedMeanLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;andrewsWave&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mf">1.339</span>
        <span class="k">return</span> <span class="n">andrewsWaveLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;leastsq&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">leastSquaresLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># use bisquare weights</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mf">4.685</span>
        <span class="c1"># k = 1.0</span>
        <span class="k">return</span> <span class="n">bisquareLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="huberLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.huberLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">huberLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Huber location weights</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.ndarray</span>
<span class="sd">        Residuals</span>
<span class="sd">    k : float</span>
<span class="sd">        Tuning parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        The robust weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="c1"># relying on numpy doing the right thing when dividing by zero</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="bisquareLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.bisquareLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">bisquareLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Bisquare location weights</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.ndarray</span>
<span class="sd">        Residuals</span>
<span class="sd">    k : float</span>
<span class="sd">        Tuning parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        The robust weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="n">threshR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="n">k</span><span class="p">))</span>
    <span class="c1"># threshR = np.maximum(-1*ones, threshR)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">threshR</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="hampelLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.hampelLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">hampelLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Hampel location weights</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.ndarray</span>
<span class="sd">        Residuals</span>
<span class="sd">    k : float</span>
<span class="sd">        Tuning parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        The robust weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">val</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="trimmedMeanLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.trimmedMeanLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">trimmedMeanLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Trimmed mean location weights</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.ndarray</span>
<span class="sd">        Residuals</span>
<span class="sd">    k : float</span>
<span class="sd">        Tuning parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        The robust weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">weights</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="andrewsWaveLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.andrewsWaveLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">andrewsWaveLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Andrews Wave location weights</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.ndarray</span>
<span class="sd">        Residuals</span>
<span class="sd">    k : float</span>
<span class="sd">        Tuning parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        The robust weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="n">testVal</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">testVal</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="leastSquaresLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.leastSquaresLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">leastSquaresLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Least squares weights, which are all equal to 1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.ndarray</span>
<span class="sd">        Residuals</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        The robust weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="sampleMedian"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.sampleMedian">[docs]</a><span class="k">def</span> <span class="nf">sampleMedian</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the median of an array</span>

<span class="sd">    Mean is not a robust estimator of locations as it can be broken by a single outlying value. The median is a more robust choice.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Data for which to calculate median</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The median</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="sampleMAD"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.sampleMAD">[docs]</a><span class="k">def</span> <span class="nf">sampleMAD</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Median absolute deviation</span>

<span class="sd">    The standard deviation is not robust against outliers, hence use the MAD.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Data for which to calculate MAD</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The MAD    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">absData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">mad</span> <span class="o">=</span> <span class="n">sampleMedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">absData</span> <span class="o">-</span> <span class="n">sampleMedian</span><span class="p">(</span><span class="n">absData</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">mad</span> <span class="o">/</span> <span class="mf">0.67448975019608171</span></div>


<div class="viewcode-block" id="sampleMAD0"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.sampleMAD0">[docs]</a><span class="k">def</span> <span class="nf">sampleMAD0</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Median absolute deviation using an estimate of the location as 0</span>

<span class="sd">    When the location estimate is zero (rather than the median), the MAD essentially reduces to a median. This should be over non zero data. Useful for calculating variance of residuals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Data for which to calculate MAD. This is often residuals when using 0 as an estimate of location. </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The MAD using zero as an esimate of location   </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">absData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">inputIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">absData</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">mad</span> <span class="o">=</span> <span class="n">sampleMedian</span><span class="p">(</span><span class="n">absData</span><span class="p">[</span><span class="n">inputIndices</span><span class="p">])</span>
    <span class="c1"># mad = sampleMedian(np.absolute(data))</span>
    <span class="k">return</span> <span class="n">mad</span> <span class="o">/</span> <span class="mf">0.67448975019608171</span></div>


<div class="viewcode-block" id="eps"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.eps">[docs]</a><span class="k">def</span> <span class="nf">eps</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Small number</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        A small number for quitting robust regression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="mf">0.0001</span></div>


<div class="viewcode-block" id="maxIter"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.maxIter">[docs]</a><span class="k">def</span> <span class="nf">maxIter</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Maximum number of iterations</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The maximum number of iterations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="mi">100</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Neeraj Shah

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>