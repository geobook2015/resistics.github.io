

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>resistics.utilities.utilsRobust &mdash; resistics 0.0.5 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css\custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> resistics
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conventions.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../formats.html">Data formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cookbook.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../donate.html">Donate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">resistics</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>resistics.utilities.utilsRobust</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for resistics.utilities.utilsRobust</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">linalg</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>

<span class="c1"># get the print</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsPrint</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># The source for these functions is Robust Statisitics, Huber, 2009</span>
<span class="c1"># in general, linear regression is# have observations y and predictors A</span>
<span class="c1"># y is multiple observations/response</span>
<span class="c1"># x are the independent variables and is unknown</span>
<span class="c1"># and y is a linear function of x =&gt; y = Ax</span>
<span class="c1"># y = nobs</span>
<span class="c1"># A = nobs * nregressors</span>
<span class="c1"># x = nregressors</span>


<span class="c1"># 2 STAGE ROBUST ESTIMATES</span>
<div class="viewcode-block" id="mmestimateModel"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.mmestimateModel">[docs]</a><span class="k">def</span> <span class="nf">mmestimateModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># get options</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">intercept</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span>
    <span class="c1"># this uses an initial mestimate with huber to give a measure of scale</span>
    <span class="c1"># and then a second with bisquare or hampel weights</span>
    <span class="k">if</span> <span class="s2">&quot;initial&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;scale&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">][</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">][</span><span class="s2">&quot;resids&quot;</span><span class="p">])</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;huber&quot;</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="n">intercept</span>
        <span class="p">)</span>
        <span class="c1"># now do another, but with a different weighting function</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">][</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="c1"># kwargs[&quot;initial&quot;][&quot;params&quot;] = params # put the new solution in, because simply then doing bisquare, which has zero weights, might mess things up</span>
        <span class="c1"># kwargs[&quot;initial&quot;][&quot;resids&quot;] = resids</span>
        <span class="n">params2</span><span class="p">,</span> <span class="n">resids2</span><span class="p">,</span> <span class="n">scale2</span><span class="p">,</span> <span class="n">weights2</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;bisquare&quot;</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="n">intercept</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;huber&quot;</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="n">intercept</span>
        <span class="p">)</span>
        <span class="c1"># now do another, but with a different weighting function</span>
        <span class="n">params2</span><span class="p">,</span> <span class="n">resids2</span><span class="p">,</span> <span class="n">scale2</span><span class="p">,</span> <span class="n">weights2</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;bisquare&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="n">intercept</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">params2</span><span class="p">,</span> <span class="n">resids2</span><span class="p">,</span> <span class="n">scale2</span><span class="p">,</span> <span class="n">weights2</span></div>


<div class="viewcode-block" id="smestimateModel"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.smestimateModel">[docs]</a><span class="k">def</span> <span class="nf">smestimateModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># this uses an initial mestimate with huber to give a measure of scale</span>
    <span class="c1"># and then a second with bisquare or hampel weights</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;huber&quot;</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="c1"># now do another, but with a different weighting function</span>
    <span class="n">params2</span><span class="p">,</span> <span class="n">residuals2</span><span class="p">,</span> <span class="n">scale2</span><span class="p">,</span> <span class="n">weights2</span> <span class="o">=</span> <span class="n">mestimateModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span></div>


<span class="c1"># def reWLS(A, y, **kwargs):</span>
<span class="c1"># 	# begin with a bounded S-estimate</span>
<span class="c1"># 	# then compute the REWLS</span>
<span class="c1"># 	components = setimateModel(A, y, kwargs)</span>

<span class="c1"># 	# now do the REWLS iterations</span>


<span class="c1"># ORDINARY LEAST SQUARES</span>
<div class="viewcode-block" id="olsModel"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.olsModel">[docs]</a><span class="k">def</span> <span class="nf">olsModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]:</span>
        <span class="c1"># add a constant term for the intercept</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">A</span><span class="p">))</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">resids</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span></div>


<span class="c1"># ROBUST LEAST SQUARES</span>
<span class="c1"># mestimate model</span>
<span class="c1"># good for dependent outliers</span>
<span class="c1"># not robust against independent outliers (called leverage points)</span>
<div class="viewcode-block" id="mestimateModel"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.mestimateModel">[docs]</a><span class="k">def</span> <span class="nf">mestimateModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># get options</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># calculate the leverage</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pnRatio</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">n</span>

    <span class="c1"># calculate the projection matrix</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">Pdiag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">del</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">Pdiag</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="n">leverageScale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="n">leverageWeights</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span>
        <span class="n">Pdiag</span> <span class="o">/</span> <span class="n">leverageScale</span><span class="p">,</span> <span class="s2">&quot;huber&quot;</span>
    <span class="p">)</span>  <span class="c1"># this should nowhere be equal to zero because of the previous line</span>

    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># add column of ones for constant term</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">A</span><span class="p">))</span>

    <span class="c1"># see whether to do an initial OLS model or whether one is provided</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">initialFromDict</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">olsModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">resids</span><span class="p">)</span>

    <span class="c1"># if an initial model was not provided but an initial scale was, replace the one here</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span>

    <span class="c1"># standardised residuals and weights</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">resids</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">leverageWeights</span>
    <span class="p">)</span>

    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="c1"># standardise and calculate weights</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">])</span>
            <span class="o">*</span> <span class="n">leverageWeights</span>
        <span class="p">)</span>
        <span class="c1"># increment iteration and save weightsNew</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="c1"># check to see whether the change is smaller than the tolerance</span>
        <span class="c1"># use the R method of checking change in residuals (can check change in params)</span>
        <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># update residuals</span>
            <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
            <span class="k">break</span>
        <span class="c1"># update residuals</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span></div>


<span class="c1"># this is the s-estimate</span>
<span class="c1"># which has a different scaling version</span>
<span class="c1"># def sestimateModel(A, y, **kwargs):</span>
<span class="c1"># 	# get options</span>
<span class="c1"># 	options = parseKeywords(kwargs)</span>
<span class="c1"># 	#generalPrint(&quot;S-Estimate&quot;, &quot;Using weight function = {}&quot;.format(weightFnc))</span>
<span class="c1"># 	if options[&quot;intercept&quot;] == True:</span>
<span class="c1"># 		# add column of ones for constant term</span>
<span class="c1"># 		A = np.hstack((np.ones(shape=(A.shape[0],1), dtype=&quot;complex&quot;), A))</span>

<span class="c1"># 	# see whether to do an initial OLS model or whether one is provided</span>
<span class="c1"># 	if options[&quot;initial&quot;]:</span>
<span class="c1"># 		params, resids, scale = initialFromDict(options[&quot;initial&quot;])</span>
<span class="c1"># 	else:</span>
<span class="c1"># 		params, resids, squareResid, rank, s = olsModel(A, y)</span>
<span class="c1"># 		scale = sampleMAD0(resids)</span>

<span class="c1"># 	# standardised residuals and weights</span>
<span class="c1"># 	resids = resids/scale</span>
<span class="c1"># 	weights = getRobustLocationWeights(resids, options[&quot;weights&quot;])</span>

<span class="c1"># 	# iteratively weighted least squares</span>
<span class="c1"># 	iteration = 0</span>
<span class="c1"># 	while iteration &lt; options[&quot;maxiter&quot;]:</span>
<span class="c1"># 		# do the weighted least-squares</span>
<span class="c1"># 		Anew, ynew = weightLS(A, y, weights)</span>
<span class="c1"># 		componentsNew, squareResidNew, rankNew, sNew = linalg.lstsq(Anew, ynew)</span>
<span class="c1"># 		residualsNew = y - np.dot(A, componentsNew)</span>
<span class="c1"># 		# now for s estimate, the new scale is calculated differently</span>
<span class="c1"># 		scale = sestimateScale(residualsNew)</span>
<span class="c1"># 		# standardised residuals</span>
<span class="c1"># 		residualsNew = residualsNew/scale</span>
<span class="c1"># 		weightsNew = getRobustLocationWeights(residualsNew, weightFnc)</span>

<span class="c1"># 		# increment iteration</span>
<span class="c1"># 		iteration = iteration + 1</span>
<span class="c1"># 		weights = weightsNew</span>

<span class="c1"># 		# check to see whether the change is smaller than the tolerance</span>
<span class="c1"># 		change = linalg.norm(componentsNew-components)/linalg.norm(componentsNew)</span>
<span class="c1"># 		changeResids = linalg.norm(residualsNew-residuals)/linalg.norm(residualsNew)</span>
<span class="c1"># 		if changeResids &lt; eps():</span>
<span class="c1"># 			# update components</span>
<span class="c1"># 			components = componentsNew</span>
<span class="c1"># 			break</span>
<span class="c1"># 		# update components</span>
<span class="c1"># 		components = componentsNew</span>

<span class="c1"># 	#generalPrint(&quot;S-Estimate&quot;, &quot;Robust regression quit after {} iterations&quot;.format(iteration))</span>
<span class="c1"># 	# at the end, return the components</span>
<span class="c1"># 	return components, weights</span>


<span class="c1"># a bounded influence estimator</span>
<div class="viewcode-block" id="chatterjeeMachler"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.chatterjeeMachler">[docs]</a><span class="k">def</span> <span class="nf">chatterjeeMachler</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># get options</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># generalPrint(&quot;S-Estimate&quot;, &quot;Using weight function = {}&quot;.format(weightFnc))</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># add column of ones for constant term</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">A</span><span class="p">))</span>

    <span class="c1"># now calculate p and n</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pnRatio</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">n</span>

    <span class="c1"># calculate the projection matrix</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">Pdiag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">del</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span>
    <span class="c1"># and save an array for later</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">Pdiag</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="n">weightsNom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">Pdiag</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># weights for the first iteration</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pnRatio</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">weights</span>
        <span class="n">residsAbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="n">residsMedian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">residsAbs</span><span class="p">)</span>
        <span class="c1"># now compute the new weights</span>
        <span class="n">weightsDenom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">residsAbs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">residsMedian</span>
        <span class="p">)</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="n">weightsNom</span> <span class="o">/</span> <span class="n">weightsDenom</span>

        <span class="c1"># increment iteration</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check to see whether the change is smaller than the tolerance</span>
            <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
                <span class="c1"># update resids</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
                <span class="k">break</span>
        <span class="c1"># update resids</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="chatterjeeMachlerMod"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.chatterjeeMachlerMod">[docs]</a><span class="k">def</span> <span class="nf">chatterjeeMachlerMod</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># using the weights in chaterjeeMachler means that min resids val in median(resids)</span>
    <span class="c1"># instead, use M estimate weights with a modified residual which includes a measure of leverage</span>
    <span class="c1"># for this, use residuals / (1-p)^2</span>
    <span class="c1"># I wonder if this will have a divide by zero bug</span>

    <span class="c1"># now calculate p and n</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pnRatio</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">n</span>

    <span class="c1"># calculate the projection matrix</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">Pdiag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">del</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span>
    <span class="n">Pdiag</span> <span class="o">=</span> <span class="n">Pdiag</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.0000000001</span><span class="p">)</span>
    <span class="n">locP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="n">scaleP</span> <span class="o">=</span> <span class="n">sampleMAD</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">)</span>
    <span class="c1"># bound = locP + 6*scaleP</span>
    <span class="n">bound</span> <span class="o">=</span> <span class="n">locP</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">scaleP</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Pdiag</span> <span class="o">&gt;</span> <span class="n">bound</span><span class="p">)</span>
    <span class="n">Pdiag</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99999</span>
    <span class="n">leverageMeas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">Pdiag</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># weights for the first iteration</span>
    <span class="c1"># this is purely based on the leverage</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pnRatio</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Pdiag</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

    <span class="c1"># get options</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># generalPrint(&quot;S-Estimate&quot;, &quot;Using weight function = {}&quot;.format(weightFnc))</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># add column of ones for constant term</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">A</span><span class="p">))</span>

    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">weights</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsNew</span> <span class="o">/</span> <span class="n">leverageMeas</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>

        <span class="c1"># standardise and calculate weights</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsNew</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">residsNew</span><span class="p">,</span> <span class="s2">&quot;huber&quot;</span><span class="p">)</span>
        <span class="c1"># increment iteration</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check to see whether the change is smaller than the tolerance</span>
            <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
                <span class="c1"># update resids</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
                <span class="k">break</span>
        <span class="c1"># update resids</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>

    <span class="c1"># now do the same again, but with a different function</span>
    <span class="c1"># do the least squares solution</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">olsModel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">resids</span> <span class="o">=</span> <span class="n">resids</span> <span class="o">/</span> <span class="n">leverageMeas</span>
    <span class="n">resids</span> <span class="o">=</span> <span class="n">resids</span> <span class="o">/</span> <span class="n">scale</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="s2">&quot;trimmedMean&quot;</span><span class="p">)</span>
    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">weights</span>

        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsNew</span> <span class="o">/</span> <span class="n">leverageMeas</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>

        <span class="c1"># standardise and calculate weights</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsNew</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">residsNew</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">])</span>
        <span class="c1"># increment iteration</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="c1"># check to see whether the change is smaller than the tolerance</span>
        <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># update resids</span>
            <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
            <span class="k">break</span>
        <span class="c1"># update resids</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>

    <span class="c1"># at the end, return the components</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">weights</span></div>


<span class="c1"># Another regression method based on Hadi distances</span>
<span class="c1"># implemented from the paper A Re-Weighted Least Squares Method for Robust Regression Estimation</span>
<span class="c1"># Billor, Hadi</span>
<div class="viewcode-block" id="chatterjeeMachlerHadi"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.chatterjeeMachlerHadi">[docs]</a><span class="k">def</span> <span class="nf">chatterjeeMachlerHadi</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># basic info</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parseKeywords</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># for the distances, will use absX - do this before adding intercept term</span>
    <span class="c1"># a column of all ones will cause problems with non full rank covariance matrices</span>
    <span class="n">absX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="c1"># now calculate p and n</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">absX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">absX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># we treat the X matrix as a multivariate matrix with n observations and p variables</span>
    <span class="c1"># first need to find a basic subset free of outliers</span>
    <span class="n">correctionFactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">chi</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">chi2bound</span> <span class="o">=</span> <span class="n">correctionFactor</span> <span class="o">*</span> <span class="n">chi</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    <span class="c1"># calculate h, this is the size of the firt basic subset</span>
    <span class="c1"># note that this is the value h, the index of the hth element is h-1</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># here, only want the integer part of this</span>
    <span class="c1"># need to get the coordinatewise medians - this is the median of the columns</span>
    <span class="n">medians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">absX</span><span class="p">)</span>
    <span class="c1"># now compute the matrix to help calculate the distance</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">absX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">medians</span>
        <span class="n">A</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span>

    <span class="c1"># now calculate initial distances</span>
    <span class="n">dInit</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">medians</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

    <span class="c1"># now get the h smallest values of d</span>
    <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dInit</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">sortOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">h</span><span class="p">]</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span>
        <span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>  <span class="c1"># observations in rows, columns are variables</span>
    <span class="n">dH</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>

    <span class="c1"># rearrange into n observations into order and partition into two initial subsets</span>
    <span class="c1"># one subset p+1, the n-p-1</span>
    <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dH</span><span class="p">)</span>
    <span class="n">indicesBasic</span> <span class="o">=</span> <span class="n">sortOrder</span><span class="p">[:</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1"># there is a rank issue here, but ignore for now - natural observations will presumably be full rank</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indicesBasic</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indicesBasic</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>

    <span class="c1"># create the basic subset</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
    <span class="k">if</span> <span class="n">increment</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># here, limiting to 100 iterations of this</span>
    <span class="k">while</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">:</span>
        <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">sortOrder</span><span class="p">[:</span><span class="n">r</span><span class="p">]</span>  <span class="c1"># indices start from zero, hence the - 1</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">increment</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="n">increment</span>

    <span class="c1"># now the second part = add more points and exclude outliers to basic set</span>
    <span class="c1"># all distances above r+1 = outliers</span>
    <span class="c1"># r = p + 1</span>
    <span class="c1"># increment = (n - 1 - r)/100</span>
    <span class="k">while</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">dist2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist2</span><span class="p">[</span><span class="n">sortOrder</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">chi2bound</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c1"># then leave, everything else is an outlier - it would be good if this could be saved somehow</span>
        <span class="c1"># otherwise, continue adding points</span>
        <span class="n">sortOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">sortOrder</span><span class="p">[:</span><span class="n">r</span><span class="p">]</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">absX</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">absX</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">increment</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="n">increment</span>

    <span class="c1"># now with the Hadi distances calculated, can proceed to do the robust regression</span>
    <span class="c1"># normalise and manipulate Hadi distances</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="c1"># for the median, use the basic subset</span>
    <span class="c1"># indicesBasic = sortOrder[:r]</span>
    <span class="c1"># distMedian = np.median(dist[indicesBasic]) # I am using on indicesBasic</span>
    <span class="n">distMedian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>  <span class="c1"># the paper suggests using the median of the complete</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">distMedian</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">dist2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist2</span><span class="p">)</span>

    <span class="c1"># calculate first set of weights - this is simply dist</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">dist</span>

    <span class="c1"># now add the additional constant intercept column if required</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># add column of ones for constant term</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">),</span> <span class="n">X</span><span class="p">))</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># iteratively weighted least squares</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]:</span>
        <span class="c1"># do the weighted least-squares</span>
        <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span> <span class="o">=</span> <span class="n">weightLS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">paramsNew</span><span class="p">,</span> <span class="n">squareResidNew</span><span class="p">,</span> <span class="n">rankNew</span><span class="p">,</span> <span class="n">sNew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">paramsNew</span><span class="p">)</span>
        <span class="c1"># check residsNew to make sure not all zeros (i.e. will happen in undetermined or equally determined system)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
            <span class="c1"># then return everything here</span>
            <span class="k">return</span> <span class="n">paramsNew</span><span class="p">,</span> <span class="n">residsNew</span><span class="p">,</span> <span class="n">weights</span>

        <span class="n">residsAbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
        <span class="n">residsSquare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">residsAbs</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">residsNew</span> <span class="o">=</span> <span class="n">residsSquare</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">residsSquare</span><span class="p">)</span>
        <span class="n">residsMedian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">residsAbs</span><span class="p">)</span>

        <span class="c1"># calculate the new weights</span>
        <span class="n">tmpDenom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">residsNew</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">residsMedian</span>
        <span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">tmpDenom</span>
        <span class="n">weightsNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># increment iteration</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weightsNew</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">paramsNew</span>

        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check to see whether the change is smaller than the tolerance</span>
            <span class="n">changeResids</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span> <span class="o">-</span> <span class="n">resids</span><span class="p">)</span> <span class="o">/</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residsNew</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">changeResids</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">():</span>
                <span class="c1"># update resids</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>
                <span class="k">break</span>
        <span class="c1"># update resids</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">residsNew</span>

    <span class="c1"># at the end, return the components</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="calculateDistCMH"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.calculateDistCMH">[docs]</a><span class="k">def</span> <span class="nf">calculateDistCMH</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">):</span>
    <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">mean</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">dist</span></div>


<span class="c1"># a bounded influence estimator</span>
<span class="c1"># this is good against leverage points</span>
<span class="c1"># def schweppeModel(A, y, **kwargs):</span>


<span class="c1"># helper functions</span>
<span class="c1"># Weighted least squares:</span>
<span class="c1"># sqrt(weights) * y = sqrt(weights) * A * x</span>
<span class="c1"># is equivalent to</span>
<span class="c1"># A&#39; *weights* y = A&#39; * weights * A x (note A&#39; transpose is the hermitian transpose)</span>
<span class="c1"># i.e. both y and A are multiplied the square root of the weights</span>
<div class="viewcode-block" id="weightLS"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.weightLS">[docs]</a><span class="k">def</span> <span class="nf">weightLS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="n">ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>
    <span class="n">Anew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">Anew</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Anew</span><span class="p">,</span> <span class="n">ynew</span></div>


<span class="c1"># calculate various values for returning</span>
<span class="c1"># from the robust regression solution</span>
<span class="c1"># this includes residuals and variances for</span>
<span class="c1"># error calculations</span>
<span class="c1"># def varsForReturn(residuals):</span>


<div class="viewcode-block" id="hermitianTranspose"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.hermitianTranspose">[docs]</a><span class="k">def</span> <span class="nf">hermitianTranspose</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span></div>


<span class="c1"># simple function that returns the intial model</span>
<span class="c1"># from a provided initial model dictionary</span>
<span class="c1"># this helps for two stage robust regression methods</span>
<div class="viewcode-block" id="initialFromDict"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.initialFromDict">[docs]</a><span class="k">def</span> <span class="nf">initialFromDict</span><span class="p">(</span><span class="n">initDict</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">initDict</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> <span class="n">initDict</span><span class="p">[</span><span class="s2">&quot;resids&quot;</span><span class="p">],</span> <span class="n">initDict</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="parseKeywords"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.parseKeywords">[docs]</a><span class="k">def</span> <span class="nf">parseKeywords</span><span class="p">(</span><span class="n">keywords</span><span class="p">):</span>
    <span class="c1"># general function to parse keywords</span>
    <span class="c1"># can be used in a number of different algorithms</span>
    <span class="c1"># and there will simply be redundant keywords</span>
    <span class="n">outDict</span> <span class="o">=</span> <span class="n">defaultDictionary</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">keywords</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outDict</span>

    <span class="k">if</span> <span class="s2">&quot;weights&quot;</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
        <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;maxiter&quot;</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
        <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;initial&quot;</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
        <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;scale&quot;</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
        <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;intercept&quot;</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
        <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">outDict</span></div>


<div class="viewcode-block" id="defaultDictionary"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.defaultDictionary">[docs]</a><span class="k">def</span> <span class="nf">defaultDictionary</span><span class="p">():</span>
    <span class="n">outDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bisquare&quot;</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;maxiter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxIter</span><span class="p">()</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">outDict</span></div>


<span class="c1">######################</span>
<span class="c1">### LOCATION WEIGHTING FUNCTIONS</span>
<span class="c1">### Functions for re-weighting least squares rows</span>
<span class="c1">######################</span>
<div class="viewcode-block" id="getRobustLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.getRobustLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">getRobustLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
    <span class="c1"># the second argument, k, is a tuning constant</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;huber&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mf">1.345</span>
        <span class="c1"># k = 0.5</span>
        <span class="k">return</span> <span class="n">huberLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;hampel&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">return</span> <span class="n">hampelLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;trimmedMean&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">trimmedMeanLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;andrewsWave&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mf">1.339</span>
        <span class="k">return</span> <span class="n">andrewsWaveLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;leastsq&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">leastSquaresLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># use bisquare weights</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mf">4.685</span>
        <span class="c1"># k = 1.0</span>
        <span class="k">return</span> <span class="n">bisquareLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>


<span class="c1"># relying on numpy doing the right thing</span>
<span class="c1"># when dividing by zero</span>
<div class="viewcode-block" id="huberLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.huberLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">huberLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="bisquareLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.bisquareLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">bisquareLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>  <span class="c1"># biweight</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="n">threshR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="n">k</span><span class="p">))</span>
    <span class="c1"># threshR = np.maximum(-1*ones, threshR)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">threshR</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">real</span></div>
    <span class="c1"># for scale weights</span>


<div class="viewcode-block" id="hampelLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.hampelLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">hampelLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">val</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="trimmedMeanLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.trimmedMeanLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">trimmedMeanLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">weights</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="andrewsWaveLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.andrewsWaveLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">andrewsWaveLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="n">testVal</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">testVal</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">real</span></div>


<span class="c1"># least squares has no weighting</span>
<div class="viewcode-block" id="leastSquaresLocationWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.leastSquaresLocationWeights">[docs]</a><span class="k">def</span> <span class="nf">leastSquaresLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span></div>


<span class="c1">######################</span>
<span class="c1">### SCALE WEIGHTING FUNCTIONS</span>
<span class="c1">### Functions for re-weighting least squares rows</span>
<span class="c1">######################</span>
<div class="viewcode-block" id="getRobustScaleWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.getRobustScaleWeights">[docs]</a><span class="k">def</span> <span class="nf">getRobustScaleWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
    <span class="c1"># k is a tuning parameter</span>
    <span class="c1"># k = 1.56</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mf">4.685</span>
    <span class="k">return</span> <span class="n">bisquareScaleWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="bisquareScaleWeights"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.bisquareScaleWeights">[docs]</a><span class="k">def</span> <span class="nf">bisquareScaleWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># r = r/k</span>
    <span class="n">tmp1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">)</span></div>


<span class="c1"># def sestimateScale(r, k):</span>

<span class="c1"># def alphaTrimmedScale(r, k):</span>


<span class="c1"># LOCATION ESTIMATORS</span>
<span class="c1"># The mean is not a robust estimator of location</span>
<span class="c1"># These are other methods of location estimation</span>
<span class="c1"># SCALE ESTIMATORS</span>
<span class="c1"># equivalent, the sd is not a robust measurement of</span>
<span class="c1"># dispersion</span>
<div class="viewcode-block" id="sampleMedian"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.sampleMedian">[docs]</a><span class="k">def</span> <span class="nf">sampleMedian</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="sampleMAD"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.sampleMAD">[docs]</a><span class="k">def</span> <span class="nf">sampleMAD</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="c1"># the MAD is the median</span>
    <span class="n">absData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">mad</span> <span class="o">=</span> <span class="n">sampleMedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">absData</span> <span class="o">-</span> <span class="n">sampleMedian</span><span class="p">(</span><span class="n">absData</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">mad</span> <span class="o">/</span> <span class="mf">0.67448975019608171</span></div>


<span class="c1"># this uses an estimate of the location as 0</span>
<div class="viewcode-block" id="sampleMAD0"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.sampleMAD0">[docs]</a><span class="k">def</span> <span class="nf">sampleMAD0</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="c1"># the MAD is the median - this should be over non zero data</span>
    <span class="n">absData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">inputIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">absData</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">mad</span> <span class="o">=</span> <span class="n">sampleMedian</span><span class="p">(</span><span class="n">absData</span><span class="p">[</span><span class="n">inputIndices</span><span class="p">])</span>
    <span class="c1"># mad = sampleMedian(np.absolute(data))</span>
    <span class="k">return</span> <span class="n">mad</span> <span class="o">/</span> <span class="mf">0.67448975019608171</span></div>


<span class="c1"># compute the m-estimate of location and scale</span>
<span class="c1"># through iteration, beginning with sample median for mean</span>
<span class="c1"># and madn for dispersion</span>
<div class="viewcode-block" id="mestimate"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.mestimate">[docs]</a><span class="k">def</span> <span class="nf">mestimate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;bisquare&quot;</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="s2">&quot;bisquare&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;location&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;scale&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">kwards</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">sampleMedian</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sampleMAD</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
    <span class="k">while</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">maxIter</span><span class="p">():</span>
        <span class="c1"># calculate outlyingness</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span>
        <span class="c1"># calculate new set of weights using window function</span>
        <span class="n">weights1</span> <span class="o">=</span> <span class="n">getRobustLocationWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">location</span><span class="p">)</span>
        <span class="n">weights2</span> <span class="o">=</span> <span class="n">getRobustScaleWeights</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="c1"># now weight the data (observations)</span>
        <span class="c1"># in calculation of new mean and sigma</span>
        <span class="n">new_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights1</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights1</span><span class="p">)</span>
        <span class="n">new_sigma2</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">delta</span><span class="p">())</span>
        <span class="n">new_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">new_sigma2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_mean</span> <span class="o">-</span> <span class="n">mean</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">()</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># if not breaking, update mean and sigma</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">new_mean</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">new_sigma</span>
    <span class="c1"># return mean and sigma</span>
    <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span></div>


<span class="c1"># SIGMA FUNCTIONS</span>
<span class="c1"># Robust measures of outlyingness</span>
<div class="viewcode-block" id="threeSigmaMAD"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.threeSigmaMAD">[docs]</a><span class="k">def</span> <span class="nf">threeSigmaMAD</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="c1"># calculate deviation from MAD</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">sampleMedian</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">/</span> <span class="n">sampleMAD</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<span class="c1"># ROBUST CORRELATION</span>
<span class="c1"># For measuring similarity between datasets</span>


<span class="c1"># A FEW USEFUL NUMBERS</span>
<div class="viewcode-block" id="eps"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.eps">[docs]</a><span class="k">def</span> <span class="nf">eps</span><span class="p">():</span>
    <span class="c1"># A small number of stopping iterations</span>
    <span class="k">return</span> <span class="mf">0.0001</span></div>


<div class="viewcode-block" id="delta"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.delta">[docs]</a><span class="k">def</span> <span class="nf">delta</span><span class="p">():</span>
    <span class="k">return</span> <span class="mf">0.5</span></div>


<div class="viewcode-block" id="maxIter"><a class="viewcode-back" href="../../../api/resistics.utilities.utilsRobust.html#resistics.utilities.utilsRobust.maxIter">[docs]</a><span class="k">def</span> <span class="nf">maxIter</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">100</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Neeraj Shah

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>