

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>resistics.calculators.processorSingleSite &mdash; resistics 0.0.6.dev2 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> resistics
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conventions.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../formats.html">Data formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cookbook.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../donate.html">Donate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">resistics</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>resistics.calculators.processorSingleSite</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for resistics.calculators.processorSingleSite</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">interp</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="c1"># import from package</span>
<span class="kn">from</span> <span class="nn">resistics.calculators.calculator</span> <span class="k">import</span> <span class="n">Calculator</span>
<span class="kn">from</span> <span class="nn">resistics.calculators.windowSelector</span> <span class="k">import</span> <span class="n">WindowSelector</span>
<span class="kn">from</span> <span class="nn">resistics.ioHandlers.transferFunctionWriter</span> <span class="k">import</span> <span class="n">TransferFunctionWriter</span>
<span class="kn">from</span> <span class="nn">resistics.dataObjects.transferFunctionData</span> <span class="k">import</span> <span class="n">TransferFunctionData</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsIO</span> <span class="k">import</span> <span class="n">checkAndMakeDir</span><span class="p">,</span> <span class="n">fileFormatSampleFreq</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsPrint</span> <span class="k">import</span> <span class="n">generalPrint</span><span class="p">,</span> <span class="n">warningPrint</span><span class="p">,</span> <span class="n">blockPrint</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsSmooth</span> <span class="k">import</span> <span class="n">smooth1d</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsRobust</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">sampleMAD0</span><span class="p">,</span>
    <span class="n">hermitianTranspose</span><span class="p">,</span>
    <span class="n">olsModel</span><span class="p">,</span>
    <span class="n">chatterjeeMachler</span><span class="p">,</span>
    <span class="n">mmestimateModel</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="ProcessorSingleSite"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite">[docs]</a><span class="k">class</span> <span class="nc">ProcessorSingleSite</span><span class="p">(</span><span class="n">Calculator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs single site transfer function calculations </span>

<span class="sd">    By default, the ProcessorSingleSite is setup to calculate the impedance tensor using Hx, Hy as input channels and Ex, Ey as output channels. To calculate the Tipper, the appropriate input and output channels have to be set.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    winSelector : WindowSelector</span>
<span class="sd">        A window selector object which defines which windows to use in the linear model</span>
<span class="sd">    decParams : DecimationParameters</span>
<span class="sd">        DecimationParameters object with information about the decimation scheme</span>
<span class="sd">    winParams : WindowParameters</span>
<span class="sd">        WindowParameters object with information about the windowing</span>
<span class="sd">    outpath : str </span>
<span class="sd">        Location to put the calculated transfer functions (Edi files)</span>
<span class="sd">    inSite : str </span>
<span class="sd">        The site to use for the input channels </span>
<span class="sd">    inChannels: List[str] ([&quot;Hx&quot;, &quot;Hy&quot;])</span>
<span class="sd">        List of hannels to use as input channels for the linear system</span>
<span class="sd">    inSize : int </span>
<span class="sd">        Number of input channels</span>
<span class="sd">    outSite : str </span>
<span class="sd">        The site to use for the output channels</span>
<span class="sd">    outChannels : List[str] ([&quot;Ex&quot;, &quot;Ey&quot;])</span>
<span class="sd">        List of channels to use as output channels for the linear system</span>
<span class="sd">    outSize : int</span>
<span class="sd">        Number of output channels</span>
<span class="sd">    allChannels : List[str] </span>
<span class="sd">        inChannels and outChannels combined into a single list</span>
<span class="sd">    crossChannels : List[str] </span>
<span class="sd">        The channels to calculate the cross spectra out for</span>
<span class="sd">    intercept : bool (default False)</span>
<span class="sd">        Flag for including an intercept (static) term in the linear system</span>
<span class="sd">    method : str (options, &quot;ols&quot;, &quot;cm&quot;) </span>
<span class="sd">        String for describing what solution method to use</span>
<span class="sd">    win : str (default hanning)</span>
<span class="sd">        Window function to use in robust solution</span>
<span class="sd">    winSmooth : int (default -1)</span>
<span class="sd">        The size of the window smoother. If -1, this will be autocalculated based on data size</span>
<span class="sd">    postpend : str (default &quot;&quot;)</span>
<span class="sd">        String to postpend to the output filename to help file management</span>
<span class="sd">    evalFreq : List[float] or np.ndarray</span>
<span class="sd">        The evaluation frequencies</span>
<span class="sd">    impedances : List</span>

<span class="sd">    variances : List</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__(proj, winSelector, outpath)</span>
<span class="sd">        Initialise with a Project instance and MaskData instance</span>
<span class="sd">    setInput(inSite, inChannels)</span>
<span class="sd">        Set the input site and channels</span>
<span class="sd">    setOutput(outSite, outChannels)</span>
<span class="sd">        Set the output site and channels</span>
<span class="sd">    process()</span>
<span class="sd">        Process the spectra to calculate the transfer function</span>
<span class="sd">    getWindowSmooth()</span>
<span class="sd">        Get the window smooth length</span>
<span class="sd">    calcEvalFrequencyData(freq, evalFreq, winDataMatrix)</span>
<span class="sd">        Calculate power spectra at the evaluation frequencies (using interpolation)</span>
<span class="sd">    smoothSpectralEstimates(data)</span>
<span class="sd">        Smooth the data across the spectral estimates    </span>
<span class="sd">    checkForBadValues(numWindows, data)</span>
<span class="sd">        Check the spectral data for bad values that might cause an error   </span>
<span class="sd">    prepareLinearEqn(data)</span>
<span class="sd">        Prepare regressors and observations for regression from cross-power data</span>
<span class="sd">    robustProcess(numWindows, obs, reg)      </span>
<span class="sd">        Robust regression processing   </span>
<span class="sd">    olsProcess(numWindows, obs, reg)      </span>
<span class="sd">        Ordinary least squares processing</span>
<span class="sd">    stackedProcess(data)</span>
<span class="sd">        Stacked processing                  </span>
<span class="sd">    printList()</span>
<span class="sd">        Class status returned as list of strings</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winSelector</span><span class="p">:</span> <span class="n">WindowSelector</span><span class="p">,</span> <span class="n">outpath</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Intialise the processor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        winSelector : WindowSelector</span>
<span class="sd">            A window selector instance</span>
<span class="sd">        outpath : str</span>
<span class="sd">            The path to write the transfer function data to</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span> <span class="o">=</span> <span class="n">winSelector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decParams</span> <span class="o">=</span> <span class="n">winSelector</span><span class="o">.</span><span class="n">decParams</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">winParams</span> <span class="o">=</span> <span class="n">winSelector</span><span class="o">.</span><span class="n">winParams</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outpath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">outpath</span>

        <span class="c1"># default parameters for user options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inSite</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;dummy&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hx&quot;</span><span class="p">,</span> <span class="s2">&quot;Hy&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outSite</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;dummy&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="s2">&quot;Ey&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossChannels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span>
        <span class="c1"># solution options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cm&quot;</span>
        <span class="c1"># smoothing options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">win</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hanning&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">winSmooth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># output filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postpend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># evaluation frequency data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">impedances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variances</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="ProcessorSingleSite.setInput"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.setInput">[docs]</a>    <span class="k">def</span> <span class="nf">setInput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inSite</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inChannels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set information about input site and channels</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inSite : str</span>
<span class="sd">            Site to use for input channel data</span>
<span class="sd">        inChannels : List[str]</span>
<span class="sd">            Channels to use as the input in the linear system</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inSite</span> <span class="o">=</span> <span class="n">inSite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span> <span class="o">=</span> <span class="n">inChannels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inChannels</span><span class="p">)</span>
        <span class="c1"># set all and cross channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossChannels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.setOutput"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.setOutput">[docs]</a>    <span class="k">def</span> <span class="nf">setOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outSite</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">outChannels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set information about output site and channels</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inSite : str</span>
<span class="sd">            Site to use for output channel data</span>
<span class="sd">        inChannels : List[str]</span>
<span class="sd">            Channels to use as the output in the linear system</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outSite</span> <span class="o">=</span> <span class="n">outSite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span> <span class="o">=</span> <span class="n">outChannels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outChannels</span><span class="p">)</span>
        <span class="c1"># set all and cross channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossChannels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.process"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Process spectra data</span>

<span class="sd">        The processing sequence for each decimation level is as below:</span>

<span class="sd">        1. Get shared (unmasked) windows for all relevant sites (inSite and outSite)</span>
<span class="sd">        2. For shared unmasked windows</span>
<span class="sd">            </span>
<span class="sd">            - Calculate out the cross-power spectra.</span>
<span class="sd">            - Interpolate calculated cross-power data to the evaluation frequencies for the decimation level.</span>
<span class="sd">        </span>
<span class="sd">        3. For each evaluation frequency</span>
<span class="sd">            </span>
<span class="sd">            - Do the robust processing to calculate the transfer function at that evaluation frequency.</span>

<span class="sd">        The spectral power data is smoothed as this tends to improve results. The smoothing can be changed by setting the smoothing parameters. This method is still subject to change in the future as it is an area of active work</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numLevels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decParams</span><span class="o">.</span><span class="n">numLevels</span>
        <span class="k">for</span> <span class="n">iDec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numLevels</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printText</span><span class="p">(</span><span class="s2">&quot;Processing decimation level </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iDec</span><span class="p">))</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decParams</span><span class="o">.</span><span class="n">getSampleFreqLevel</span><span class="p">(</span><span class="n">iDec</span><span class="p">)</span>
            <span class="c1"># get the number of all shared windows and the number of unmasked windows</span>
            <span class="c1"># unmasked windows are ones that will actually be used in the calculation</span>
            <span class="n">numWindows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span><span class="o">.</span><span class="n">getNumSharedWindows</span><span class="p">(</span><span class="n">iDec</span><span class="p">)</span>
            <span class="n">unmaskedWindows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span><span class="o">.</span><span class="n">getUnmaskedWindowsLevel</span><span class="p">(</span><span class="n">iDec</span><span class="p">)</span>
            <span class="n">numUnmasked</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmaskedWindows</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printText</span><span class="p">(</span>
                <span class="s2">&quot;Total shared windows for decimation level = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numWindows</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printText</span><span class="p">(</span>
                <span class="s2">&quot;Total unmasked windows for decimation level = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numUnmasked</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">numUnmasked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">printText</span><span class="p">(</span>
                    <span class="s2">&quot;No unmasked windows found at this decimation level (</span><span class="si">{:d}</span><span class="s2">), continuing to next level&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">iDec</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># continue to next decimation level</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printText</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> windows will be processed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numUnmasked</span><span class="p">))</span>

            <span class="c1"># get the evaluation frequencies</span>
            <span class="n">evalFreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decParams</span><span class="o">.</span><span class="n">getEvalFrequenciesForLevel</span><span class="p">(</span><span class="n">iDec</span><span class="p">)</span>
            <span class="c1"># set some variables</span>
            <span class="n">totalSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span>
            <span class="n">numEvalFreq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">evalFreq</span><span class="p">)</span>
            <span class="n">dataSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span><span class="o">.</span><span class="n">getDataSize</span><span class="p">(</span><span class="n">iDec</span><span class="p">)</span>
            <span class="n">freq</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dataSize</span><span class="p">)</span>
            <span class="c1"># get the window smoothing params</span>
            <span class="n">smoothLen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWindowSmooth</span><span class="p">(</span><span class="n">datasize</span><span class="o">=</span><span class="n">dataSize</span><span class="p">)</span>

            <span class="c1"># create the data array for each evaluation frequency</span>
            <span class="c1"># keep the spectral power information for all windows</span>
            <span class="n">evalFreqData</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">numEvalFreq</span><span class="p">,</span> <span class="n">numWindows</span><span class="p">,</span> <span class="n">totalSize</span><span class="p">,</span> <span class="n">totalSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
            <span class="p">)</span>

            <span class="c1"># an array for the window data</span>
            <span class="n">winSpectraMatrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">totalSize</span><span class="p">,</span> <span class="n">totalSize</span><span class="p">,</span> <span class="n">dataSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
            <span class="p">)</span>
            <span class="n">winDataArray</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">totalSize</span><span class="p">,</span> <span class="n">dataSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
            <span class="p">)</span>

            <span class="c1"># loop over unmasked windows</span>
            <span class="n">localWin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">global2local</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">iWin</span> <span class="ow">in</span> <span class="n">unmaskedWindows</span><span class="p">:</span>
                <span class="c1"># do the local to global map</span>
                <span class="n">global2local</span><span class="p">[</span><span class="n">iWin</span><span class="p">]</span> <span class="o">=</span> <span class="n">localWin</span>

                <span class="c1"># get the window for the input site</span>
                <span class="n">inSF</span><span class="p">,</span> <span class="n">inReader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span><span class="o">.</span><span class="n">getSpecReaderForWindow</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inSite</span><span class="p">,</span> <span class="n">iDec</span><span class="p">,</span> <span class="n">iWin</span>
                <span class="p">)</span>
                <span class="n">inData</span> <span class="o">=</span> <span class="n">inReader</span><span class="o">.</span><span class="n">readBinaryWindowGlobal</span><span class="p">(</span><span class="n">iWin</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>

                <span class="c1"># get the window and channels for the output site</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSite</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSite</span><span class="p">:</span>
                    <span class="n">outSF</span><span class="p">,</span> <span class="n">outReader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span><span class="o">.</span><span class="n">getSpecReaderForWindow</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">outSite</span><span class="p">,</span> <span class="n">iDec</span><span class="p">,</span> <span class="n">iWin</span>
                    <span class="p">)</span>
                    <span class="n">outData</span> <span class="o">=</span> <span class="n">outReader</span><span class="o">.</span><span class="n">readBinaryWindowGlobal</span><span class="p">(</span><span class="n">iWin</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outData</span> <span class="o">=</span> <span class="n">inData</span>

                <span class="c1"># get data into the right part of the arrays</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">):</span>
                    <span class="n">winDataArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inData</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
                    <span class="n">winDataArray</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inSize</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">outData</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

                <span class="c1"># and now can fill the parts of the matrix</span>
                <span class="c1"># recall, smooth the power spectra</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">totalSize</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">totalSize</span><span class="p">):</span>
                        <span class="n">winSpectraMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">smooth1d</span><span class="p">(</span>
                            <span class="n">winDataArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">winDataArray</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
                            <span class="n">smoothLen</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">win</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                            <span class="c1"># due to complex symmetry</span>
                            <span class="n">winSpectraMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                                <span class="n">winSpectraMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                            <span class="p">)</span>

                <span class="c1"># after running through all windows, calculate various spectral properties at evaluation frequencies</span>
                <span class="c1"># using interpolation</span>
                <span class="n">evalFreqData</span><span class="p">[:,</span> <span class="n">localWin</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcEvalFrequencyData</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">,</span> <span class="n">evalFreq</span><span class="p">,</span> <span class="n">winSpectraMatrix</span>
                <span class="p">)</span>

                <span class="c1"># increment local window</span>
                <span class="n">localWin</span> <span class="o">=</span> <span class="n">localWin</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># now all the data has been collected</span>
            <span class="c1"># for each evaluation frequency, do the robust processing</span>
            <span class="c1"># and get the evaluation frequency data</span>
            <span class="k">for</span> <span class="n">eIdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numEvalFreq</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">printText</span><span class="p">(</span>
                    <span class="s2">&quot;Processing evaluation frequency = </span><span class="si">{:.6f}</span><span class="s2"> [Hz], period = </span><span class="si">{:.6f}</span><span class="s2"> [s]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">evalFreq</span><span class="p">[</span><span class="n">eIdx</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">evalFreq</span><span class="p">[</span><span class="n">eIdx</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># get the constrained windows for the evaluation frequency</span>
                <span class="n">evalFreqWindows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span><span class="o">.</span><span class="n">getWindowsForFreq</span><span class="p">(</span><span class="n">iDec</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">evalFreqWindows</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># no windows meet constraints</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">printText</span><span class="p">(</span><span class="s2">&quot;No windows found - possibly due to masking&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">localWinIndices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">iW</span> <span class="ow">in</span> <span class="n">evalFreqWindows</span><span class="p">:</span>
                    <span class="n">localWinIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">global2local</span><span class="p">[</span><span class="n">iW</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">printText</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{:d}</span><span class="s2"> windows will be solved for&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">localWinIndices</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="c1"># restrict processing to data that meets constraints for this evaluation frequency</span>
                <span class="c1"># add to class vars</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">evalFreq</span><span class="p">[</span><span class="n">eIdx</span><span class="p">])</span>
                <span class="c1"># solution using all components</span>
                <span class="n">numSolveWindows</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepareLinearEqn</span><span class="p">(</span>
                    <span class="n">evalFreqData</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">localWinIndices</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">robustProcess</span><span class="p">(</span><span class="n">numSolveWindows</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
                <span class="c1"># tmp1, tmp2 = self.olsProcess(numSolveWindows, obs, reg)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">impedances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printWarning</span><span class="p">(</span>
                <span class="s2">&quot;No data was found at any decimation level for insite </span><span class="si">{}</span><span class="s2">, outsite </span><span class="si">{}</span><span class="s2">, sampling frequency </span><span class="si">{}</span><span class="s2"> and specdir </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inSite</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outSite</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">decParams</span><span class="o">.</span><span class="n">getSampleFreqLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span><span class="o">.</span><span class="n">specdir</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># write out all the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeTF</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">winSelector</span><span class="o">.</span><span class="n">specdir</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">postpend</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">impedances</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variances</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.getWindowSmooth"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.getWindowSmooth">[docs]</a>    <span class="k">def</span> <span class="nf">getWindowSmooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Window smoothing length</span>

<span class="sd">        Power spectra data is smoothed. This returns the size of the smoothing window.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        datasize : int</span>
<span class="sd">            The size of the data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smoothLen : int</span>
<span class="sd">            Smoothing size</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if window size specified by user</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSmooth</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSmooth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winSmooth</span>
        <span class="c1"># if not, calculate based on datasize</span>
        <span class="k">if</span> <span class="s2">&quot;datasize&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">winSmooth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;datasize&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">16.0</span>
            <span class="k">if</span> <span class="n">winSmooth</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">3</span>  <span class="c1"># minimum smoothing</span>
            <span class="c1"># otherwise round to nearest odd number</span>
            <span class="n">winSmooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">winSmooth</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># this is floor division</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">winSmooth</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># otherwise, return a default value</span>
        <span class="k">return</span> <span class="mi">15</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.calcEvalFrequencyData"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.calcEvalFrequencyData">[docs]</a>    <span class="k">def</span> <span class="nf">calcEvalFrequencyData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">evalFreq</span><span class="p">,</span> <span class="n">winDataMatrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate spectral power data at evaluation frequencies</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray</span>
<span class="sd">            Frequency array of spectra data</span>
<span class="sd">        evalFreq : np.ndarray</span>
<span class="sd">            Evaluation frequencies for the decimation level</span>
<span class="sd">        winDataMatrix : np.ndarray</span>
<span class="sd">            Array holding spectral power data at frequencies freq        </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : np.ndarray</span>
<span class="sd">            Spectral power data interpolated to evaluation frequencies </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inShape</span><span class="p">:</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="n">winDataMatrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">evalFreq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">inShape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inShape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="c1"># get data from winDataMatrix</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inShape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inShape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">interpFunc</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">winDataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">interpVals</span> <span class="o">=</span> <span class="n">interpFunc</span><span class="p">(</span><span class="n">evalFreq</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eFreq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">evalFreq</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpVals</span><span class="p">[</span><span class="n">eIdx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.smoothSpectralEstimates"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.smoothSpectralEstimates">[docs]</a>    <span class="k">def</span> <span class="nf">smoothSpectralEstimates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Smooth spectral estimates across windows</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np.ndarray </span>
<span class="sd">            Cross-spectra data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : np.ndarray </span>
<span class="sd">            Smoothed cross-spectra data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">winSmooth</span> <span class="o">=</span> <span class="mi">9</span>
        <span class="n">totalChans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">totalChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">totalChans</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">smooth1d</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">winSmooth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">win</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.checkForBadValues"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.checkForBadValues">[docs]</a>    <span class="k">def</span> <span class="nf">checkForBadValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numWindows</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check data for bad values and remove</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        numWindows : int</span>
<span class="sd">            The number of windows</span>
<span class="sd">        data : np.ndarray </span>
<span class="sd">            Cross-spectra data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numGoodWindows : int</span>
<span class="sd">            The number of good windows</span>
<span class="sd">        goodData : np.ndarray</span>
<span class="sd">            The cross-spectra data with bad windows removed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">finiteArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">numWindows</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">iW</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numWindows</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">iW</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">finiteArray</span><span class="p">[</span><span class="n">iW</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">numGoodWindows</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">finiteArray</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numGoodWindows</span> <span class="o">==</span> <span class="n">numWindows</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numWindows</span><span class="p">,</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">printWarning</span><span class="p">(</span>
            <span class="s2">&quot;Bad data found...number of windows reduced from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">numWindows</span><span class="p">,</span> <span class="n">numGoodWindows</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">goodWindowIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">finiteArray</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numGoodWindows</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">goodWindowIndices</span><span class="p">]</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.prepareLinearEqn"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.prepareLinearEqn">[docs]</a>    <span class="k">def</span> <span class="nf">prepareLinearEqn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Prepare data as a linear equation for the robust regression</span>

<span class="sd">        This prepares the data for the following type of solution,</span>

<span class="sd">        .. math::</span>
<span class="sd">            y = Ax,</span>

<span class="sd">        where :math:`y` is the observations, :math:`A` is the regressors and :math:`x` is the unknown. </span>

<span class="sd">        The number of observations is number of windows * number of cross-power channels</span>
<span class="sd">        The shapes of the arrays are as follows:</span>
<span class="sd">        </span>
<span class="sd">            - y is (number of output channels, number of observations)</span>
<span class="sd">            - A is (number of output channels, number of observations, number of input channels)</span>
<span class="sd">            - x is (number of output channels, number of input channels)</span>

<span class="sd">        Consider the impedance tensor,</span>

<span class="sd">        .. math::</span>
<span class="sd">            :nowrap:</span>

<span class="sd">            \begin{eqnarray}</span>
<span class="sd">            E_x &amp; = &amp; Z_{xx} H_x + Z_{xy} H_y \\</span>
<span class="sd">            E_y &amp; = &amp; Z_{yx} H_x + Z_{yy} H_y </span>
<span class="sd">            \end{eqnarray}  </span>

<span class="sd">        Here, there are two input channels, :math:`H_x`, :math:`H_y` and two output channels :math:`E_x` and :math:`E_y`. In total, there are four components of the unknown impedance tensor, :math:`Z_{xx}`, :math:`Z_{xy}`, :math:`Z_{yx}`, :math:`Z_{yy}` (number of input channels * number of output channels). The number of observations is the number of windows multiplied by the number of channels used for cross-power spectra.     </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np.ndarray</span>
<span class="sd">            Cross-power spectral data at evaluation frequencies</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numWindows : int</span>
<span class="sd">            The number of windows included in the regression (after bad value removal)</span>
<span class="sd">        obs : np.ndarray</span>
<span class="sd">            Observations array</span>
<span class="sd">        reg : np.ndarray </span>
<span class="sd">            Regressors array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numWindows</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># check for bad values</span>
        <span class="n">numWindows</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkForBadValues</span><span class="p">(</span><span class="n">numWindows</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">crossSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crossChannels</span><span class="p">)</span>
        <span class="c1"># for each output variable, have number of input regressor variables</span>
        <span class="c1"># construct our arrays</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="n">crossSize</span> <span class="o">*</span> <span class="n">numWindows</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="n">crossSize</span> <span class="o">*</span> <span class="n">numWindows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">iW</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numWindows</span><span class="p">):</span>
            <span class="n">iOffset</span> <span class="o">=</span> <span class="n">iW</span> <span class="o">*</span> <span class="n">crossSize</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">crossChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crossChannels</span><span class="p">):</span>
                    <span class="c1"># this is the observation row where i is the observed output</span>
                    <span class="n">crossIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">crossChan</span><span class="p">)</span>
                    <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">iOffset</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">iW</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">crossIndex</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">):</span>
                        <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">iOffset</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">iW</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">crossIndex</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">numWindows</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">reg</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.robustProcess"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.robustProcess">[docs]</a>    <span class="k">def</span> <span class="nf">robustProcess</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">numWindows</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">reg</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Robust regression processing</span>

<span class="sd">        Perform robust regression processing using observations and regressors for a single evaluation frequency. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        numWindows : int</span>
<span class="sd">            The number of windows</span>
<span class="sd">        obs : np.ndarray</span>
<span class="sd">            The observations</span>
<span class="sd">        reg : np.ndarray</span>
<span class="sd">            The regressors</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : np.ndarray</span>
<span class="sd">            The solution to the regression problem</span>
<span class="sd">        varOutput : np.ndarray</span>
<span class="sd">            The variance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">crossSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crossChannels</span><span class="p">)</span>
        <span class="c1"># create array for output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
        <span class="n">varOutput</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="c1"># solve</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
            <span class="n">observation</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">predictors</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="c1"># save the output</span>
            <span class="n">out</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">chatterjeeMachler</span><span class="p">(</span>
                <span class="n">predictors</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span>
            <span class="p">)</span>
            <span class="c1"># out, resids, scale, weights = mmestimateModel(predictors, observation, intercept=self.intercept)</span>

            <span class="c1"># now take the weights, apply to the observations and predictors, stack the appropriate rows</span>
            <span class="n">observation2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">crossSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
            <span class="n">predictors2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">crossSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iChan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">crossSize</span><span class="p">):</span>
                <span class="c1"># now need to have my indexing array</span>
                <span class="n">indexArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">iChan</span><span class="p">,</span> <span class="n">numWindows</span> <span class="o">*</span> <span class="n">crossSize</span><span class="p">,</span> <span class="n">crossSize</span><span class="p">)</span>
                <span class="n">weightsLim</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">indexArray</span><span class="p">]</span>
                <span class="c1"># weightsLim = weightsLim/np.sum(weightsLim) # normalise weights to 1</span>
                <span class="n">observation2</span><span class="p">[</span><span class="n">iChan</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">indexArray</span><span class="p">]</span> <span class="o">*</span> <span class="n">weightsLim</span><span class="p">)</span> <span class="o">/</span> <span class="n">numWindows</span>
                <span class="p">)</span>
                <span class="c1"># now for the regressors</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">):</span>
                    <span class="n">predictors2</span><span class="p">[</span><span class="n">iChan</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">indexArray</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">weightsLim</span><span class="p">)</span> <span class="o">/</span> <span class="n">numWindows</span>
                    <span class="p">)</span>
            <span class="n">out</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">chatterjeeMachler</span><span class="p">(</span>
                <span class="n">predictors2</span><span class="p">,</span> <span class="n">observation2</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span>
            <span class="p">)</span>
            <span class="c1"># out, resids, scale, weights = mmestimateModel(</span>
            <span class="c1">#     predictors2, observation2, intercept=self.intercept)</span>

            <span class="c1"># now calculate out the varainces - have the solution out, have the weights</span>
            <span class="c1"># recalculate out the residuals with the final solution</span>
            <span class="c1"># calculate standard deviation of residuals</span>
            <span class="c1"># and then use chatterjee machler formula to estimate variances</span>
            <span class="c1"># this needs work - better to use an empirical bootstrap method, but this will do for now</span>
            <span class="n">resids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">observation</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">predictors</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span>
                <span class="n">resids</span>
            <span class="p">)</span>  <span class="c1"># some measure of standard deviation, rather than using the standard deviation</span>
            <span class="n">residsVar</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">scale</span>
            <span class="c1"># varPred = np.dot(hermitianTranspose(predictors), weights*predictors) # need to fix this</span>
            <span class="n">varPred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hermitianTranspose</span><span class="p">(</span><span class="n">predictors</span><span class="p">),</span> <span class="n">predictors</span><span class="p">)</span>
            <span class="n">varPred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">varPred</span><span class="p">)</span>  <span class="c1"># this is a pxp matrix</span>
            <span class="n">varOut</span> <span class="o">=</span> <span class="mf">1.91472</span> <span class="o">*</span> <span class="n">residsVar</span> <span class="o">*</span> <span class="n">varPred</span>
            <span class="n">varOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">varOut</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># this should be a real number</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">varOutput</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">varOut</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
                <span class="n">varOutput</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">varOut</span>

        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">varOutput</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.olsProcess"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.olsProcess">[docs]</a>    <span class="k">def</span> <span class="nf">olsProcess</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">numWindows</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">reg</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Ordinary least squares regression processing</span>

<span class="sd">        Perform ordinary least regression processing using observations and regressors for a single evaluation frequency. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        numWindows : int</span>
<span class="sd">            The number of windows</span>
<span class="sd">        obs : np.ndarray</span>
<span class="sd">            The observations</span>
<span class="sd">        reg : np.ndarray</span>
<span class="sd">            The regressors</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : np.ndarray</span>
<span class="sd">            The solution to the regression problem</span>
<span class="sd">        varOutput : np.ndarray</span>
<span class="sd">            The variance        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create array for output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
        <span class="n">varOutput</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="c1"># solve</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
            <span class="n">observation</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">predictors</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="c1"># save the output</span>
            <span class="n">out</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">olsModel</span><span class="p">(</span>
                <span class="n">predictors</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span>
            <span class="p">)</span>
            <span class="c1"># if self.intercept:</span>
            <span class="c1"># 	output[i] = out[1:]</span>
            <span class="c1"># else:</span>
            <span class="c1"># 	output[i] = out</span>

            <span class="c1"># now calculate out the varainces - have the solution out, have the weights</span>
            <span class="c1"># recalculate out the residuals with the final solution</span>
            <span class="c1"># calculate standard deviation of residuals</span>
            <span class="c1"># and then use chatterjee machler formula to estimate variances</span>
            <span class="c1"># this needs work - better to use an empirical bootstrap method, but this will do for now</span>
            <span class="n">resids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">observation</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">predictors</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">sampleMAD0</span><span class="p">(</span>
                <span class="n">resids</span>
            <span class="p">)</span>  <span class="c1"># some measure of standard deviation, rather than using the standard deviation</span>
            <span class="n">residsVar</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">scale</span>
            <span class="c1"># varPred = np.dot(hermitianTranspose(predictors), weights*predictors) # need to fix this</span>
            <span class="n">varPred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hermitianTranspose</span><span class="p">(</span><span class="n">predictors</span><span class="p">),</span> <span class="n">predictors</span><span class="p">)</span>
            <span class="n">varPred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">varPred</span><span class="p">)</span>  <span class="c1"># this is a pxp matrix</span>
            <span class="n">varOut</span> <span class="o">=</span> <span class="mf">1.91472</span> <span class="o">*</span> <span class="n">residsVar</span> <span class="o">*</span> <span class="n">varPred</span>
            <span class="n">varOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">varOut</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># this should be a real number</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">varOutput</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">varOut</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
                <span class="n">varOutput</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">varOut</span>

        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">varOutput</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.stackedProcess"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.stackedProcess">[docs]</a>    <span class="k">def</span> <span class="nf">stackedProcess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Ordinary least squares processing after stacking</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np.ndarray</span>
<span class="sd">            Cross-spectra data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : np.ndarray</span>
<span class="sd">            The solution to the regression problem</span>
<span class="sd">        varOutput : np.ndarray</span>
<span class="sd">            The variance        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># then do various sums</span>
        <span class="n">numWindows</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">crossSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crossChannels</span><span class="p">)</span>
        <span class="c1"># unweighted sum (i.e. normal solution)</span>
        <span class="n">unWeightedSum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">unWeightedSum</span> <span class="o">=</span> <span class="n">unWeightedSum</span> <span class="o">/</span> <span class="n">numWindows</span>

        <span class="c1"># for each output variable, have ninput regressor variables</span>
        <span class="c1"># let&#39;s construct our arrays</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="n">crossSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="n">crossSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">crossChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crossChannels</span><span class="p">):</span>
                <span class="n">crossIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">crossChan</span><span class="p">)</span>
                <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">unWeightedSum</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inSize</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">crossIndex</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">):</span>
                    <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">unWeightedSum</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">crossIndex</span><span class="p">]</span>

        <span class="c1"># create array for output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
            <span class="n">observation</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">predictors</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="c1"># save the output</span>
            <span class="n">out</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">mmestimateModel</span><span class="p">(</span>
                <span class="n">predictors</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.writeTF"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.writeTF">[docs]</a>    <span class="k">def</span> <span class="nf">writeTF</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">specdir</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">postpend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">variances</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the transfer function file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        specdir : str</span>
<span class="sd">            The spectra data being used for the transfer function estimate</span>
<span class="sd">        postpend : str</span>
<span class="sd">            The optional postpend to the transfer function file</span>
<span class="sd">        data : np.ndarray</span>
<span class="sd">            The transfer function estimates</span>
<span class="sd">        variances : np.ndarray</span>
<span class="sd">            The transfer function variances</span>
<span class="sd">        remotesite : str, optional</span>
<span class="sd">            Optionally, if there is a remote site</span>
<span class="sd">        remotechans : List[str], optional</span>
<span class="sd">            Optionally add the remote channels if there is a remote site</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># path for writing out to</span>
        <span class="n">sampleFreqStr</span> <span class="o">=</span> <span class="n">fileFormatSampleFreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decParams</span><span class="o">.</span><span class="n">sampleFreq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">postpend</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_fs</span><span class="si">{:s}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSite</span><span class="p">,</span> <span class="n">sampleFreqStr</span><span class="p">,</span> <span class="n">specdir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_fs</span><span class="si">{:s}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outSite</span><span class="p">,</span> <span class="n">sampleFreqStr</span><span class="p">,</span> <span class="n">specdir</span><span class="p">,</span> <span class="n">postpend</span>
            <span class="p">)</span>
        <span class="n">datapath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outpath</span><span class="p">,</span> <span class="n">sampleFreqStr</span><span class="p">)</span>
        <span class="n">checkAndMakeDir</span><span class="p">(</span><span class="n">datapath</span><span class="p">)</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="c1"># now construct the transferFunctionData object</span>
        <span class="n">numFreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">dataDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">varDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">dataArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">numFreq</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
                <span class="n">varArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ifreq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numFreq</span><span class="p">):</span>
                    <span class="n">dataArray</span><span class="p">[</span><span class="n">ifreq</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ifreq</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">varArray</span><span class="p">[</span><span class="n">ifreq</span><span class="p">]</span> <span class="o">=</span> <span class="n">variances</span><span class="p">[</span><span class="n">ifreq</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">dataDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataArray</span>
                <span class="n">varDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">varArray</span>
        <span class="n">tfData</span> <span class="o">=</span> <span class="n">TransferFunctionData</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">dataDict</span><span class="p">,</span> <span class="n">varDict</span><span class="p">)</span>
        <span class="c1"># now make the writer and write out</span>
        <span class="n">tfWriter</span> <span class="o">=</span> <span class="n">TransferFunctionWriter</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">tfData</span><span class="p">)</span>
        <span class="n">tfWriter</span><span class="o">.</span><span class="n">setHeaders</span><span class="p">(</span>
            <span class="n">sampleFreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decParams</span><span class="o">.</span><span class="n">sampleFreq</span><span class="p">,</span>
            <span class="n">insite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inSite</span><span class="p">,</span>
            <span class="n">inchans</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span><span class="p">,</span>
            <span class="n">outsite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outSite</span><span class="p">,</span>
            <span class="n">outchans</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;remotesite&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">tfWriter</span><span class="o">.</span><span class="n">addHeader</span><span class="p">(</span><span class="s2">&quot;remotesite&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;remotesite&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;remotechans&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">tfWriter</span><span class="o">.</span><span class="n">addHeader</span><span class="p">(</span><span class="s2">&quot;remotechans&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;remotechans&quot;</span><span class="p">])</span>
        <span class="n">tfWriter</span><span class="o">.</span><span class="n">write</span><span class="p">()</span></div>

<div class="viewcode-block" id="ProcessorSingleSite.printList"><a class="viewcode-back" href="../../../api/resistics.calculators.processorSingleSite.html#resistics.calculators.processorSingleSite.ProcessorSingleSite.printList">[docs]</a>    <span class="k">def</span> <span class="nf">printList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Class information as a list of strings</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of strings with information</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">textLst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;In Site = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inSite</span><span class="p">))</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;In Channels = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChannels</span><span class="p">))</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Out Site = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSite</span><span class="p">))</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Out Channels = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChannels</span><span class="p">))</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Sample frequency = </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decParams</span><span class="o">.</span><span class="n">sampleFreq</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">textLst</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Neeraj Shah

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>