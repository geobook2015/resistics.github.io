

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>resistics.calculators.statisticCalculator &mdash; resistics 0.0.5 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css\custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> resistics
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conventions.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../formats.html">Data formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cookbook.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../donate.html">Donate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">resistics</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>resistics.calculators.statisticCalculator</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for resistics.calculators.statisticCalculator</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">interp</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># import from package</span>
<span class="kn">from</span> <span class="nn">resistics.calculators.calculator</span> <span class="k">import</span> <span class="n">Calculator</span>
<span class="kn">from</span> <span class="nn">resistics.dataObjects.spectrumData</span> <span class="k">import</span> <span class="n">SpectrumData</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsPrint</span> <span class="k">import</span> <span class="n">listToString</span><span class="p">,</span> <span class="n">arrayToString</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsRobust</span> <span class="k">import</span> <span class="n">olsModel</span>
<span class="kn">from</span> <span class="nn">resistics.utilities.utilsSmooth</span> <span class="k">import</span> <span class="n">smooth1d</span>


<div class="viewcode-block" id="StatisticCalculator"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator">[docs]</a><span class="k">class</span> <span class="nc">StatisticCalculator</span><span class="p">(</span><span class="n">Calculator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate statistics for data restriction</span>

<span class="sd">    Statistics are calculated out for each evaluation frequency in each window. Therefore, there are nwindow*nfreq statistics in total.</span>

<span class="sd">    This class was written to speed up statistic calculations. Many statistics need the same data, for example power spectra. This class calculates and reuses some common values amongst the various statistics to improve calculation speed.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    evalFreq : List</span>
<span class="sd">        List of evaluation frequencies</span>
<span class="sd">    winLen : int</span>
<span class="sd">        Window length for spectra calculations</span>
<span class="sd">    winType : str</span>
<span class="sd">        Window function to apply to time data before fourier transform</span>
<span class="sd">    inChans : List[str]</span>
<span class="sd">        Input channels</span>
<span class="sd">    inSize : int</span>
<span class="sd">        Number of input channels</span>
<span class="sd">    outChans : List[str]</span>
<span class="sd">        Output channels </span>
<span class="sd">    outSize : int</span>
<span class="sd">        Number of output channels</span>
<span class="sd">    specChans : List[str] </span>
<span class="sd">        The channels for which to calculate auto and cross power spectra</span>
<span class="sd">    remoteChans : List[str]</span>
<span class="sd">        Remote reference channels</span>
<span class="sd">    psdChans : List[str] </span>
<span class="sd">        Power spectral density channels</span>
<span class="sd">    cohPairs : List[List[str]]</span>
<span class="sd">        Pairs of channels for coherence calculations</span>
<span class="sd">    polDirs : List[List[str]]</span>
<span class="sd">        Pairs of channels of polarisation direction calculation</span>
<span class="sd">    spec: Dict = {}</span>

<span class="sd">    tfCalculated : bool </span>
<span class="sd">        Boolean flag to show that the transfer function has been calculated for a window</span>
<span class="sd">    remoteCalculated : bool </span>
<span class="sd">        Boolean flag to show...</span>
<span class="sd">    intercept : bool   </span>
<span class="sd">        Boolean flag to include an intercept into the </span>
<span class="sd">    outData: Dict = {}</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__()</span>
<span class="sd">    getEvalFreq()</span>
<span class="sd">    getInChans()</span>
<span class="sd">    getOutChans()</span>
<span class="sd">    getSpecChans()</span>
<span class="sd">    getRemoteChans()</span>
<span class="sd">    getPSDChans()</span>
<span class="sd">    getCohPairs()</span>
<span class="sd">    getPolDirs()</span>
<span class="sd">    getAutoPower(chan)</span>
<span class="sd">    getAutoPowerEval(chan, eIdx)</span>
<span class="sd">    getCrossPower(chan1, chan2)</span>
<span class="sd">    getCrossPowerEval(chan1, chan2, eIdx)</span>
<span class="sd">    getOutData()</span>
<span class="sd">    setInChans(inChans)</span>
<span class="sd">    setOutChans(outChans)</span>
<span class="sd">    setSpectra(freq, winData, evalFreq)</span>
<span class="sd">    setIntercept(intercept)</span>
<span class="sd">    calculateSpectralMatrix()</span>
<span class="sd">    calculateEvalMatrix()</span>
<span class="sd">    addRemoteSpec(remoteData, **kwargs)</span>
<span class="sd">    calculateRemoteSpectralMatrix()</span>
<span class="sd">    calculateRemoteEvalMatrix()</span>
<span class="sd">    calculateReferenceSpectralMatrix()</span>
<span class="sd">    calculateReferenceEvalMatrix()</span>
<span class="sd">    getRemoteAutoPower(chan)</span>
<span class="sd">    getRemoteAutoPowerEval(chan, eIdx)</span>
<span class="sd">    getRemoteCrossPower(chan1, chan2)</span>
<span class="sd">    getRemoteCrossPowerEval(chan1, chan2, eIdx)</span>
<span class="sd">    getReferenceCrossPower(dataChan, remoteChan)</span>
<span class="sd">    getReferenceCrossPowerEval(dataChan, remoteChan, eIdx)</span>
<span class="sd">    interpolateToEvalFreq(data)</span>
<span class="sd">    prepareOutDict()</span>
<span class="sd">    getDataForStatName(statName)</span>
<span class="sd">    winPSD()</span>
<span class="sd">    winCoherence()</span>
<span class="sd">    winPolarisations()</span>
<span class="sd">    winPartials()</span>
<span class="sd">    winTransferFunction()</span>
<span class="sd">    winRemoteCoherence()</span>
<span class="sd">    winRemoteEqnCoherence()</span>
<span class="sd">    winRemoteAbsVal()</span>
<span class="sd">    winRemoteTransferFunction()</span>
<span class="sd">    printList()</span>
<span class="sd">        Class information returned as list of strings  </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialise the statistic calculator&quot;&quot;&quot;</span>

        <span class="c1"># default evaluation frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># power smoothing vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">winLen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">13</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">winType</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hanning&quot;</span>
        <span class="c1"># set some defaults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hx&quot;</span><span class="p">,</span> <span class="s2">&quot;Hy&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="s2">&quot;Ey&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psdChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="s2">&quot;Ey&quot;</span><span class="p">,</span> <span class="s2">&quot;Hx&quot;</span><span class="p">,</span> <span class="s2">&quot;Hy&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cohPairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="s2">&quot;Hx&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="s2">&quot;Hy&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;Ey&quot;</span><span class="p">,</span> <span class="s2">&quot;Hx&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;Ey&quot;</span><span class="p">,</span> <span class="s2">&quot;Hy&quot;</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polDirs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;Ex&quot;</span><span class="p">,</span> <span class="s2">&quot;Ey&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;Hx&quot;</span><span class="p">,</span> <span class="s2">&quot;Hy&quot;</span><span class="p">]]</span>
        <span class="c1"># set data presets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># output data and marker for transfer function calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tfCalculated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remoteCalculated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="StatisticCalculator.getEvalFreq"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getEvalFreq">[docs]</a>    <span class="k">def</span> <span class="nf">getEvalFreq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the evaluation frequency</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[float]</span>
<span class="sd">            List of evaluation frequencies</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getInChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getInChans">[docs]</a>    <span class="k">def</span> <span class="nf">getInChans</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the input channels</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[str]</span>
<span class="sd">            List of input channels</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getOutChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getOutChans">[docs]</a>    <span class="k">def</span> <span class="nf">getOutChans</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the output channels</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[str]</span>
<span class="sd">            List of output channels</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getSpecChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getSpecChans">[docs]</a>    <span class="k">def</span> <span class="nf">getSpecChans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the channels for which to calculate spectra</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[str]</span>
<span class="sd">            List of spectra channels</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getRemoteChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getRemoteChans">[docs]</a>    <span class="k">def</span> <span class="nf">getRemoteChans</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the remote reference channels</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[str]</span>
<span class="sd">            List of remote reference channels</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getPSDChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getPSDChans">[docs]</a>    <span class="k">def</span> <span class="nf">getPSDChans</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the channels to include power spectral density</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[str]</span>
<span class="sd">            List of power spectral density channels</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psdChans</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getCohPairs"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getCohPairs">[docs]</a>    <span class="k">def</span> <span class="nf">getCohPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of coherence channel pairs to calculate out</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[List[str]]</span>
<span class="sd">            List of coherence pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cohPairs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getPolDirs"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getPolDirs">[docs]</a>    <span class="k">def</span> <span class="nf">getPolDirs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Get a list of polarisation direction pairs</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[List[str]]</span>
<span class="sd">            List of polarisation direction pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polDirs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getAutoPower"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getAutoPower">[docs]</a>    <span class="k">def</span> <span class="nf">getAutoPower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the auto power for a channel</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan : str</span>
<span class="sd">            The channel for which to get the autopower</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The auto power for the channel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
        <span class="c1"># then return the autopower</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectralMatrix</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">real</span></div>

<div class="viewcode-block" id="StatisticCalculator.getAutoPowerEval"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getAutoPowerEval">[docs]</a>    <span class="k">def</span> <span class="nf">getAutoPowerEval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the auto power value for an particular evaluation frequency</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan : str</span>
<span class="sd">            The channel for which to get the autopower</span>
<span class="sd">        eIdx : int</span>
<span class="sd">            The index for the evaluation frequency</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The auto power for the channel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
        <span class="c1"># then return the autopower</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalMatrix</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">]</span><span class="o">.</span><span class="n">real</span></div>

<div class="viewcode-block" id="StatisticCalculator.getCrossPower"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getCrossPower">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossPower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">chan2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the cross power between two channels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan1 : str</span>
<span class="sd">            The first channel for the cross channels</span>
<span class="sd">        chan2 : str</span>
<span class="sd">            The second channl for the cross channels</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The cross power spectral density</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan1</span><span class="p">)</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan2</span><span class="p">)</span>
        <span class="c1"># then return the autopower</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectralMatrix</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span></div>

<div class="viewcode-block" id="StatisticCalculator.getCrossPowerEval"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getCrossPowerEval">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossPowerEval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">chan2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the cross power between two channels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan1 : str</span>
<span class="sd">            The first channel for the cross channels</span>
<span class="sd">        chan2 : str</span>
<span class="sd">            The second channl for the cross channels</span>
<span class="sd">        eIdex : int</span>
<span class="sd">            The index of the evaluation frequency</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The cross power spectral density</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan1</span><span class="p">)</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan2</span><span class="p">)</span>
        <span class="c1"># then return the autopower</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalMatrix</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">]</span></div>

<div class="viewcode-block" id="StatisticCalculator.getOutData"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getOutData">[docs]</a>    <span class="k">def</span> <span class="nf">getOutData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the output data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict</span>
<span class="sd">            The statistic output data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.setInChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.setInChans">[docs]</a>    <span class="k">def</span> <span class="nf">setInChans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the input channels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inChans : List[str]</span>
<span class="sd">            Input channels for the magnetotelluric linear system</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span> <span class="o">=</span> <span class="n">inChans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.setOutChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.setOutChans">[docs]</a>    <span class="k">def</span> <span class="nf">setOutChans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Set the output channels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inChans : List[str]</span>
<span class="sd">            Output channels for the magnetotelluric linear system</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span> <span class="o">=</span> <span class="n">outChans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.setRemoteChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.setRemoteChans">[docs]</a>    <span class="k">def</span> <span class="nf">setRemoteChans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remoteChans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the input channels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inChans : List[str]</span>
<span class="sd">            Input channels for the magnetotelluric linear system</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span> <span class="o">=</span> <span class="n">remoteChans</span></div>

<div class="viewcode-block" id="StatisticCalculator.setPSDChans"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.setPSDChans">[docs]</a>    <span class="k">def</span> <span class="nf">setPSDChans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psdChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the power spectral density channels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        psdChans : List[str]</span>
<span class="sd">            Power spectral density channels. An example input would be: [&quot;Ex&quot;, &quot;Ey&quot;, &quot;Hx&quot;, &quot;Hy&quot;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psdChans</span> <span class="o">=</span> <span class="n">psdChans</span></div>

<div class="viewcode-block" id="StatisticCalculator.setCohPairs"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.setCohPairs">[docs]</a>    <span class="k">def</span> <span class="nf">setCohPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cohPairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the power spectral density channels</span>

<span class="sd">        If cohPairs of [[&quot;Ex&quot;, &quot;Hx&quot;], [&quot;Ex&quot;, &quot;Hy&quot;], [&quot;Ey&quot;, &quot;Hx&quot;], [&quot;Ey&quot;, &quot;Hy&quot;]] are set, the following coherences will be calculated:</span>
<span class="sd">        ExHx</span>
<span class="sd">        ExHy</span>
<span class="sd">        EyHx</span>
<span class="sd">        EyHy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cohPairs : List[List[str]]</span>
<span class="sd">            Set the coherence pairs using a list of channel pairs, for example: [[&quot;Ex&quot;, &quot;Hx&quot;], [&quot;Ex&quot;, &quot;Hy&quot;], [&quot;Ey&quot;, &quot;Hx&quot;], [&quot;Ey&quot;, &quot;Hy&quot;]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cohPairs</span> <span class="o">=</span> <span class="n">cohPairs</span></div>

<div class="viewcode-block" id="StatisticCalculator.setPolDirs"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.setPolDirs">[docs]</a>    <span class="k">def</span> <span class="nf">setPolDirs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polDirs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the polarisation direction pairs to calculate</span>

<span class="sd">        If polDirs of [[&quot;Ex&quot;, &quot;Ey&quot;], [&quot;Hx&quot;, &quot;Hy&quot;]] are set, the following polarisation directions will be calculated:</span>
<span class="sd">        Ex Ey</span>
<span class="sd">        Hx Hy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        polDirs : List[List[str]]</span>
<span class="sd">            Set polarisation direction channel pairs, for example: [[&quot;Ex&quot;, &quot;Ey&quot;], [&quot;Hx&quot;, &quot;Hy&quot;]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">polDirs</span> <span class="o">=</span> <span class="n">polDirs</span></div>

<div class="viewcode-block" id="StatisticCalculator.setSpectra"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.setSpectra">[docs]</a>    <span class="k">def</span> <span class="nf">setSpectra</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">specData</span><span class="p">:</span> <span class="n">SpectrumData</span><span class="p">,</span> <span class="n">evalFreq</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the spectra data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray</span>
<span class="sd">            The frequency points in the spectra data</span>
<span class="sd">        specData : SpectrumData</span>
<span class="sd">            Spectrum data (i.e. spectrum data for a window)</span>
<span class="sd">        evalFreq : np.ndarray</span>
<span class="sd">            Evaluation frequency array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">specData</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span> <span class="o">=</span> <span class="n">evalFreq</span>
        <span class="c1"># self.specChans = sorted(self.spec.keys())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numChans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataSize</span> <span class="o">=</span> <span class="n">specData</span><span class="o">.</span><span class="n">dataSize</span>
        <span class="c1"># calculate the power matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculateSpectralMatrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculateEvalMatrix</span><span class="p">()</span>
        <span class="c1"># clear the out dictionary and set that transfer function not calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepareOutDict</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.setIntercept"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.setIntercept">[docs]</a>    <span class="k">def</span> <span class="nf">setIntercept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intercept</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the intercept boolean</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        intercept : bool</span>
<span class="sd">            Boolean flag for having an intercept in the transfer function calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span> <span class="o">=</span> <span class="n">intercept</span></div>

<div class="viewcode-block" id="StatisticCalculator.calculateSpectralMatrix"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.calculateSpectralMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">calculateSpectralMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate out the cross power spectral matrix</span>

<span class="sd">        The method calculates out the cross powers which will then be used in the other statistic calculations.</span>

<span class="sd">        The cross powers spectral matrix is a 3-D matrix of size:</span>
<span class="sd">        numChans * numChans * numFrequencies</span>
<span class="sd">        The elements of this are calculated by multiplying the spectra of one channel by the complex conjugate of the spectra of another channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the 3d array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectralMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="c1"># now need to go through the chans</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">):</span>
                <span class="n">chan1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="n">chan2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spectralMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">smooth1d</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="n">chan1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="n">chan2</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">winLen</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">winType</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">jj</span><span class="p">:</span>
                    <span class="c1"># conjugate symmtry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spectralMatrix</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spectralMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.calculateEvalMatrix"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.calculateEvalMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">calculateEvalMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate out the cross power spectral matrix at the evaluation frequencies</span>

<span class="sd">        The method calculates out the cross powers which will then be used in the other statistic calculations at the evaluation frequencies</span>

<span class="sd">        The cross powers spectral matrix for evaluation frequencies is a 3-D matrix of size:</span>
<span class="sd">        numChans * numChans * numEvaluationFrequencies</span>
<span class="sd">        The elements of this are calculated by taking the cross powers spectral matrix and using the result there to interpolate the values at the evaluation frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evalMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evalMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolateToEvalFreq</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spectralMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">!=</span> <span class="n">jj</span><span class="p">:</span>
                    <span class="c1"># conjugate symmtry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">evalMatrix</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span></div>

<div class="viewcode-block" id="StatisticCalculator.addRemoteSpec"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.addRemoteSpec">[docs]</a>    <span class="k">def</span> <span class="nf">addRemoteSpec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remoteData</span><span class="p">:</span> <span class="n">SpectrumData</span><span class="p">,</span> <span class="n">remoteChans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add coincident remote reference spectrum data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remoteData : SpectrumData</span>
<span class="sd">            Spectrum data (i.e. spectrum data for a window)</span>
<span class="sd">        remoteChans : List[str]</span>
<span class="sd">            The channels to use from remote reference data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpec</span> <span class="o">=</span> <span class="n">remoteData</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remoteChans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span> <span class="o">=</span> <span class="n">remoteChans</span>
        <span class="c1"># now calculate some remote reference related values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculateRemoteSpectralMatrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculateRemoteEvalMatrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculateReferenceSpectralMatrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculateReferenceEvalMatrix</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.calculateRemoteSpectralMatrix"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.calculateRemoteSpectralMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">calculateRemoteSpectralMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate out the cross power spectral matrix for the remote reference data</span>

<span class="sd">        The method calculates out the cross powers for the remote reference channels which will then be used in the other statistic calculations.</span>

<span class="sd">        The remote reference cross powers spectral matrix is a 3-D matrix of size:</span>
<span class="sd">        numRemoteChans * numRemoteChans * numFrequencies</span>
<span class="sd">        The elements of this are calculated by multiplying the spectra of one channel by the complex conjugate of the spectra of another channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the 3d array</span>
        <span class="n">numRemoteChans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpectralMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">numRemoteChans</span><span class="p">,</span> <span class="n">numRemoteChans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="c1"># now need to go through the chans</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numRemoteChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">numRemoteChans</span><span class="p">):</span>
                <span class="n">chan1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="n">chan2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpectralMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">smooth1d</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpec</span><span class="p">[</span><span class="n">chan1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteSpec</span><span class="p">[</span><span class="n">chan2</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">winLen</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">winType</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">jj</span><span class="p">:</span>
                    <span class="c1"># conjugate symmtry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpectralMatrix</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpectralMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.calculateRemoteEvalMatrix"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.calculateRemoteEvalMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">calculateRemoteEvalMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate out the cross power spectral matrix for the remote reference data at the evaluation frequencies</span>

<span class="sd">        Takes the cross power spectral data calculate for the remote reference channels and interpoaltes it to the evaluation frequencies</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the array</span>
        <span class="n">numRemoteChans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remoteEvalMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">numRemoteChans</span><span class="p">,</span> <span class="n">numRemoteChans</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numRemoteChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">numRemoteChans</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remoteEvalMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolateToEvalFreq</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpectralMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">!=</span> <span class="n">jj</span><span class="p">:</span>
                    <span class="c1"># conjugate symmtry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remoteEvalMatrix</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remoteEvalMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.calculateReferenceSpectralMatrix"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.calculateReferenceSpectralMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">calculateReferenceSpectralMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate out the cross power spectral matrix between the site spectral data and the remote reference spectral data</span>

<span class="sd">        The reference cross powers spectral matrix is a 3-D matrix of size:</span>
<span class="sd">        numChans * numRemoteChans * numFrequencies</span>
<span class="sd">        The elements of this are calculated by multiplying a channel of the site spectral data by the complex conjugate of a channel from the remote reference. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># cannot use conjugate symmetry in this case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">referenceSpectralMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">referenceSpectralMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">smooth1d</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="n">chan1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteSpec</span><span class="p">[</span><span class="n">chan2</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">winLen</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">winType</span><span class="p">,</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.calculateReferenceEvalMatrix"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.calculateReferenceEvalMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">calculateReferenceEvalMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate the remote and site cross powers spectral matrix to the evaluation frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">referenceEvalMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numChans</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">referenceEvalMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolateToEvalFreq</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">referenceSpectralMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="StatisticCalculator.getRemoteAutoPower"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getRemoteAutoPower">[docs]</a>    <span class="k">def</span> <span class="nf">getRemoteAutoPower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the auto power of a remote reference channel</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan : str</span>
<span class="sd">            The channel for which to get the autopower</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The autopower array (real for autopowers)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpectralMatrix</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">real</span></div>

<div class="viewcode-block" id="StatisticCalculator.getRemoteAutoPowerEval"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getRemoteAutoPowerEval">[docs]</a>    <span class="k">def</span> <span class="nf">getRemoteAutoPowerEval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the auto power of a remote reference channel at an evaluation frequency</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan : str</span>
<span class="sd">            The channel for which to get the autopower</span>
<span class="sd">        eIdx : int</span>
<span class="sd">            The evaluation frequency index</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The autopower of the channel at the evaluation frequency</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteEvalMatrix</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">]</span><span class="o">.</span><span class="n">real</span></div>

<div class="viewcode-block" id="StatisticCalculator.getRemoteCrossPower"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getRemoteCrossPower">[docs]</a>    <span class="k">def</span> <span class="nf">getRemoteCrossPower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">chan2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the cross power of two remote reference channels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan1 : str</span>
<span class="sd">            The first channel for the cross power</span>
<span class="sd">        chan2 : str</span>
<span class="sd">            The second channel for the cross power</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The cross power array </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan1</span><span class="p">)</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpectralMatrix</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span></div>

<div class="viewcode-block" id="StatisticCalculator.getRemoteCrossPowerEval"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getRemoteCrossPowerEval">[docs]</a>    <span class="k">def</span> <span class="nf">getRemoteCrossPowerEval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">chan2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the cross power of two remote reference channels at a single evaluation frequency</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan1 : str</span>
<span class="sd">            The first channel for the cross power</span>
<span class="sd">        chan2 : str</span>
<span class="sd">            The second channel for the cross power</span>
<span class="sd">        eIdx : int</span>
<span class="sd">            The evaluation frequency index            </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the cross power at the evaluation frequency </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan1</span><span class="p">)</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteSpectralMatrix</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">]</span></div>

<div class="viewcode-block" id="StatisticCalculator.getReferenceCrossPower"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getReferenceCrossPower">[docs]</a>    <span class="k">def</span> <span class="nf">getReferenceCrossPower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataChan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the cross power of a data channel and a remote reference channel</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataChan : str</span>
<span class="sd">            The data channel</span>
<span class="sd">        remoteChan : str</span>
<span class="sd">            The remote reference channel</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The cross power array </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dataChan</span><span class="p">)</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">remoteChan</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">referenceSpectralMatrix</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span></div>

<div class="viewcode-block" id="StatisticCalculator.getReferenceCrossPowerEval"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getReferenceCrossPowerEval">[docs]</a>    <span class="k">def</span> <span class="nf">getReferenceCrossPowerEval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dataChan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the cross power of a data channel and a remote reference channel at a single evaluation frequency</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataChan : str</span>
<span class="sd">            The data channel</span>
<span class="sd">        remoteChan : str</span>
<span class="sd">            The remote reference channel</span>
<span class="sd">        eIdx : int</span>
<span class="sd">            The evaluation frequency index              </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the cross power at the evaluation frequency </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dataChan</span><span class="p">)</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">remoteChan</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">referenceEvalMatrix</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">]</span></div>

<div class="viewcode-block" id="StatisticCalculator.interpolateToEvalFreq"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.interpolateToEvalFreq">[docs]</a>    <span class="k">def</span> <span class="nf">interpolateToEvalFreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Interpolate data on to the evaluation frequency</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np.ndarray</span>
<span class="sd">            Power spectral data defined at frequency points given in the freqs array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Data interpolated to evaluation frequencies</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">interpFunc</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">interpData</span> <span class="o">=</span> <span class="n">interpFunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interpData</span></div>

<div class="viewcode-block" id="StatisticCalculator.prepareOutDict"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.prepareOutDict">[docs]</a>    <span class="k">def</span> <span class="nf">prepareOutDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prepare output statistic output dictionary</span>
<span class="sd">        </span>
<span class="sd">        The outData dictionary is indexed in the following way:</span>
<span class="sd">        outData[evaluation frequency][statistic component] = value</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outData</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># set various calculated flags to false</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tfCalculated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remoteCalculated</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="StatisticCalculator.getDataForStatName"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.getDataForStatName">[docs]</a>    <span class="k">def</span> <span class="nf">getDataForStatName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statName</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data for a statistic</span>

<span class="sd">        Given a statitic name, this method returns data from the correct internal method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        statName : str</span>
<span class="sd">            The name of the statistic to calculate out</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict</span>
<span class="sd">            The output dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;absvalEqn&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winAbsVal</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;coherence&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winCoherence</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;powerSpectralDensity&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winPSD</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;polarisationDirection&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winPolarisations</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;partialCoherence&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winPartials</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;transferFunction&quot;</span> <span class="ow">or</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;resPhase&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfCalculated</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winTransferFunction</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;RR_coherence&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winRemoteCoherence</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;RR_coherenceEqn&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winRemoteEqnCoherence</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;RR_absvalEqn&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winRemoteAbsVal</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;RR_transferFunction&quot;</span> <span class="ow">or</span> <span class="n">statName</span> <span class="o">==</span> <span class="s2">&quot;RR_resPhase&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteCalculated</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winRemoteTransferFunction</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printError</span><span class="p">(</span>
                <span class="s2">&quot;Statistic in getDataForStatName not recognised&quot;</span><span class="p">,</span> <span class="n">quitRun</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">winCoherence</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winPSD"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winPSD">[docs]</a>    <span class="k">def</span> <span class="nf">winPSD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate power spectral densities</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># need to divide by length of time too</span>
        <span class="n">freqLen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span>
        <span class="n">timeLen</span> <span class="o">=</span> <span class="p">(</span><span class="n">freqLen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># minus 1 because time sections are usually even</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># sampling frequency</span>
        <span class="c1"># and then calculate amount of time</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">timeLen</span> <span class="o">/</span> <span class="n">fs</span>
        <span class="c1"># interpolate onto evaluation frequency and output to outData</span>
        <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eF</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPSDChans</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;psd</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eF</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span> <span class="o">/</span> <span class="n">duration</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winCoherence"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winCoherence">[docs]</a>    <span class="k">def</span> <span class="nf">winCoherence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate spectral coherence pairs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCohPairs</span><span class="p">()):</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># chan1</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># chan2</span>
            <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eF</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
                <span class="c1"># calculate the nominator and denominator</span>
                <span class="n">cohNom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)),</span> <span class="mi">2</span>
                <span class="p">)</span><span class="o">.</span><span class="n">real</span>
                <span class="n">cohDenom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span>
                    <span class="n">c2</span><span class="p">,</span> <span class="n">eIdx</span>
                <span class="p">)</span>
                <span class="c1"># save in outData</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;coh</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eF</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cohNom</span> <span class="o">/</span> <span class="n">cohDenom</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winPolarisations"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winPolarisations">[docs]</a>    <span class="k">def</span> <span class="nf">winPolarisations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate polarisation directions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPolDirs</span><span class="p">()):</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># chan1</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># chan2</span>
            <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eF</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
                <span class="c1"># now calculate the nominator and denominator</span>
                <span class="n">cohNom</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
                <span class="p">)</span>  <span class="c1"># take the real part of this</span>
                <span class="n">cohDenom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span>
                    <span class="n">c2</span><span class="p">,</span> <span class="n">eIdx</span>
                <span class="p">)</span>
                <span class="c1"># save to out dictionary</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;pol</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eF</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">cohNom</span> <span class="o">/</span> <span class="n">cohDenom</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winPartials"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winPartials">[docs]</a>    <span class="k">def</span> <span class="nf">winPartials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate partial coherencies</span>

<span class="sd">        Based on paper Weckmann, Magunia Ritter 2005.</span>
<span class="sd">        e.g. coherence Ex, Hx w.r.t Hy</span>
<span class="sd">        This currently only works for impedance tensor calculations and higher power partial coherencies are not supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Based on paper by Weckmann, Magunia Ritter 2005.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the coherences - these will be required later</span>
        <span class="n">winCoherence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">winCoherence</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">outChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eFreq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
                <span class="n">inChan1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">inChan2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">xOutIn1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">inChan1</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                <span class="n">xOutIn2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">inChan2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                <span class="n">xIn1In2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">inChan1</span><span class="p">,</span> <span class="n">inChan2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                <span class="n">xIn2In1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">inChan2</span><span class="p">,</span> <span class="n">inChan1</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                <span class="c1"># calculate out transFunc components</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span><span class="n">inChan1</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span><span class="n">inChan2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">xIn1In2</span> <span class="o">*</span> <span class="n">xIn2In1</span>
                <span class="p">)</span>
                <span class="c1"># Z1</span>
                <span class="n">Z1nom</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">xOutIn1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span><span class="n">inChan2</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span> <span class="o">-</span> <span class="n">xIn2In1</span> <span class="o">*</span> <span class="n">xOutIn2</span>
                <span class="p">)</span>
                <span class="n">Z1</span> <span class="o">=</span> <span class="n">Z1nom</span> <span class="o">/</span> <span class="n">denom</span>
                <span class="c1"># Z2</span>
                <span class="n">Z2nom</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span><span class="n">inChan1</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span> <span class="o">*</span> <span class="n">xOutIn2</span> <span class="o">-</span> <span class="n">xIn1In2</span> <span class="o">*</span> <span class="n">xOutIn1</span>
                <span class="p">)</span>
                <span class="n">Z2</span> <span class="o">=</span> <span class="n">Z2nom</span> <span class="o">/</span> <span class="n">denom</span>
                <span class="c1"># calculate bivariate coherency</span>
                <span class="n">rb</span> <span class="o">=</span> <span class="n">Z1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span>
                    <span class="n">inChan1</span><span class="p">,</span> <span class="n">outChan</span><span class="p">,</span> <span class="n">eIdx</span>
                <span class="p">)</span> <span class="o">+</span> <span class="n">Z2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">inChan2</span><span class="p">,</span> <span class="n">outChan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                <span class="n">rb</span> <span class="o">=</span> <span class="n">rb</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                <span class="c1"># now calculate out partials</span>
                <span class="c1"># calculate partial inChan, outChan1 with respect to outChan2</span>
                <span class="n">cohkey</span> <span class="o">=</span> <span class="s2">&quot;coh</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outChan</span> <span class="o">+</span> <span class="n">inChan2</span><span class="p">)</span>
                <span class="n">rp1</span> <span class="o">=</span> <span class="p">(</span><span class="n">rb</span> <span class="o">-</span> <span class="n">winCoherence</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">cohkey</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="mf">1.0</span> <span class="o">-</span> <span class="n">winCoherence</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">cohkey</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># calculate partial inChan, outChan2 with respect to outChan1</span>
                <span class="n">cohkey</span> <span class="o">=</span> <span class="s2">&quot;coh</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outChan</span> <span class="o">+</span> <span class="n">inChan1</span><span class="p">)</span>
                <span class="n">rp2</span> <span class="o">=</span> <span class="p">(</span><span class="n">rb</span> <span class="o">-</span> <span class="n">winCoherence</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">cohkey</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="mf">1.0</span> <span class="o">-</span> <span class="n">winCoherence</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">cohkey</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># now save in outDict</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="s2">&quot;bivar</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outChan</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rb</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="s2">&quot;par</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outChan</span> <span class="o">+</span> <span class="n">inChan1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rp1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="s2">&quot;par</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outChan</span> <span class="o">+</span> <span class="n">inChan2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rp2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winAbsVal"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winAbsVal">[docs]</a>    <span class="k">def</span> <span class="nf">winAbsVal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute values of the cross power spectral matrix</span>

<span class="sd">        This data is often useful for cross plotting</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eFreq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iChan</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">):</span>
                <span class="c1"># first do the outchans multiplied by every other channel</span>
                <span class="k">for</span> <span class="n">iOut</span><span class="p">,</span> <span class="n">outChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">):</span>
                    <span class="n">absval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">))</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;abs</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">chan</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">absval</span>

                <span class="c1"># then  do the inchans multiplied by every other channel</span>
                <span class="k">for</span> <span class="n">iIn</span><span class="p">,</span> <span class="n">inChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">):</span>
                    <span class="n">absval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span><span class="n">inChan</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">))</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;abs</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inChan</span><span class="p">,</span> <span class="n">chan</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">absval</span>
        <span class="c1"># return the dictionary</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winTransferFunction"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winTransferFunction">[docs]</a>    <span class="k">def</span> <span class="nf">winTransferFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate transfer function for the spectral data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">totalSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span>
        <span class="c1"># now want to calculate the transfer function for each evaluation frequency</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eFreq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
            <span class="c1"># solve transfer function</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="n">totalSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="n">totalSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">totalSize</span><span class="p">):</span>
                    <span class="c1"># this is the observation row where,i is the observed output</span>
                    <span class="c1"># idx in the evaluation frequency</span>
                    <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">eIdx</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">):</span>
                        <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossPowerEval</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">eIdx</span>
                        <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
                <span class="n">observation</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">predictors</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="c1"># now do the solution</span>
                <span class="n">out</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">olsModel</span><span class="p">(</span>
                    <span class="n">predictors</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span>
                <span class="p">)</span>
                <span class="c1"># out, resids, scale, weights	= mmestimateModel(predictors, observation, intercept=False)</span>
                <span class="c1"># not interested in the intercept (const) term</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>

            <span class="c1"># calculate components of transfer function and res and phase</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">):</span>
                    <span class="n">period</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">eFreq</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">period</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">keyRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;Res&quot;</span>
                    <span class="n">keyPhase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;Phase&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyRes</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyPhase</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase</span>
                    <span class="c1"># add the components</span>
                    <span class="n">keyReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;Real&quot;</span>
                    <span class="n">keyImag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;Imag&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyReal</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyImag</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span>
        <span class="c1"># set transfer function calculated as true</span>
        <span class="c1"># saves having to do it again</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tfCalculated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winRemoteCoherence"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winRemoteCoherence">[docs]</a>    <span class="k">def</span> <span class="nf">winRemoteCoherence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calulate coherence between data channels and remote channels</span>

<span class="sd">        For example, this is the coherence of Ex-HxR, Ex-HyR, Ey-HxR, Ey-HyR, Hx-HxR, Hx-HyR, Hy-HxR, Hy-HyR</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># now let&#39;s calculate coherency</span>
        <span class="c1"># abs(crosspower(A,B))^2/autopower(A)*autpower(B)</span>
        <span class="k">for</span> <span class="n">dataChan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specChans</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">remoteChan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">RR&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dataChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eFreq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
                    <span class="n">cohNom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPowerEval</span><span class="p">(</span><span class="n">dataChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">cohDenom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAutoPowerEval</span><span class="p">(</span>
                        <span class="n">dataChan</span><span class="p">,</span> <span class="n">eIdx</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRemoteAutoPowerEval</span><span class="p">(</span><span class="n">remoteChan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                    <span class="n">coh</span> <span class="o">=</span> <span class="n">cohNom</span> <span class="o">/</span> <span class="n">cohDenom</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">coh</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winRemoteEqnCoherence"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winRemoteEqnCoherence">[docs]</a>    <span class="k">def</span> <span class="nf">winRemoteEqnCoherence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calulates coherences for the remote reference solver equations</span>

<span class="sd">        For example, this is the coherence of Ex-HxR, Ex-HyR, Ey-HxR, Ey-HyR, Hx-HxR, Hx-HyR, Hy-HxR, Hy-HyR</span>

<span class="sd">        todo:</span>
<span class="sd">        Write more information in these comments</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># now calculate out the relevant coherencies</span>
        <span class="c1"># here we calculate the coherency between &lt;Ex,HyR&gt; and &lt;Hy,HyR&gt; for example</span>
        <span class="k">for</span> <span class="n">iOut</span><span class="p">,</span> <span class="n">outChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iIn</span><span class="p">,</span> <span class="n">inChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iRemote</span><span class="p">,</span> <span class="n">remoteChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">):</span>
                    <span class="c1"># calculate powers</span>
                    <span class="n">c1c1</span> <span class="o">=</span> <span class="n">smooth1d</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPower</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPower</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">winLen</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">winType</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">c2c2</span> <span class="o">=</span> <span class="n">smooth1d</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPower</span><span class="p">(</span><span class="n">inChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPower</span><span class="p">(</span><span class="n">inChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">winLen</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">winType</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">c1c2</span> <span class="o">=</span> <span class="n">smooth1d</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPower</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPower</span><span class="p">(</span><span class="n">inChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">winLen</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">winType</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># now interpolate</span>
                    <span class="n">c1c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolateToEvalFreq</span><span class="p">(</span><span class="n">c1c1</span><span class="p">)</span>
                    <span class="n">c2c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolateToEvalFreq</span><span class="p">(</span><span class="n">c2c2</span><span class="p">)</span>
                    <span class="n">c1c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolateToEvalFreq</span><span class="p">(</span><span class="n">c1c2</span><span class="p">)</span>
                    <span class="c1"># now calculate the nominator and denominator</span>
                    <span class="n">cohNom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">c1c2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">cohDenom</span> <span class="o">=</span> <span class="n">c1c1</span> <span class="o">*</span> <span class="n">c2c2</span>
                    <span class="n">coh</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">cohNom</span> <span class="o">/</span> <span class="n">cohDenom</span>
                    <span class="p">)</span>  <span class="c1"># cast as float - discard complex part (complex part should be zero anyway)</span>
                    <span class="c1"># now need the coherencies for the evaluation frequencies</span>
                    <span class="c1"># this involves interpolation</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">R-</span><span class="si">{}{}</span><span class="s2">R&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">,</span> <span class="n">inChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">iFreq</span><span class="p">,</span> <span class="n">eFreq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">coh</span><span class="p">[</span><span class="n">iFreq</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winRemoteAbsVal"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winRemoteAbsVal">[docs]</a>    <span class="k">def</span> <span class="nf">winRemoteAbsVal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute values of cross power spectral densities between remote refence channels and data channels</span>

<span class="sd">        This data can be useful for cross plotting</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eFreq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iOut</span><span class="p">,</span> <span class="n">outChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iRemote</span><span class="p">,</span> <span class="n">remoteChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">):</span>
                    <span class="n">absOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPowerEval</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">keyOut</span> <span class="o">=</span> <span class="s2">&quot;abs</span><span class="si">{}{}</span><span class="s2">R&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyOut</span><span class="p">]</span> <span class="o">=</span> <span class="n">absOut</span>
                    <span class="k">for</span> <span class="n">iIn</span><span class="p">,</span> <span class="n">inChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">):</span>
                        <span class="n">absIn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPowerEval</span><span class="p">(</span><span class="n">inChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">,</span> <span class="n">eIdx</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">keyIn</span> <span class="o">=</span> <span class="s2">&quot;abs</span><span class="si">{}{}</span><span class="s2">R&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyIn</span><span class="p">]</span> <span class="o">=</span> <span class="n">absIn</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.winRemoteTransferFunction"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.winRemoteTransferFunction">[docs]</a>    <span class="k">def</span> <span class="nf">winRemoteTransferFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate transfer function for the spectral data when remote reference is included too</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict : </span>
<span class="sd">            Dictionary with statistic values, indexed by [evaluation frequency][statistic component]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">eFreq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalFreq</span><span class="p">):</span>
            <span class="c1"># solve transfer function</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;complex&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">outChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">remoteChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remoteChans</span><span class="p">):</span>
                    <span class="c1"># this is the observation row where,i is the observed output</span>
                    <span class="c1"># eIdx in the evaluation frequency</span>
                    <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPowerEval</span><span class="p">(</span>
                        <span class="n">outChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">,</span> <span class="n">eIdx</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">inChan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">):</span>
                        <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getReferenceCrossPowerEval</span><span class="p">(</span>
                            <span class="n">inChan</span><span class="p">,</span> <span class="n">remoteChan</span><span class="p">,</span> <span class="n">eIdx</span>
                        <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
                <span class="n">observation</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">predictors</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="c1"># now do the solution</span>
                <span class="n">out</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">squareResid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">olsModel</span><span class="p">(</span>
                    <span class="n">predictors</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span>
                <span class="p">)</span>
                <span class="c1"># out, resids, scale, weights	= mmestimateModel(predictors, observation, intercept=False)</span>
                <span class="c1"># not interested in the intercept (const) term</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>

            <span class="c1"># calculate components of transfer function and res and phase</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outSize</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inSize</span><span class="p">):</span>
                    <span class="n">period</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">eFreq</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">period</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">keyRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;ResRR&quot;</span>
                    <span class="n">keyPhase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;PhaseRR&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyRes</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyPhase</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase</span>
                    <span class="c1"># add the components</span>
                    <span class="n">keyReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;RealRR&quot;</span>
                    <span class="n">keyImag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inChans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;ImagRR&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyReal</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outData</span><span class="p">[</span><span class="n">eFreq</span><span class="p">][</span><span class="n">keyImag</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">eIdx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span>
        <span class="c1"># set transfer function calculated as true</span>
        <span class="c1"># saves having to do it again</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remoteCalculated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOutData</span><span class="p">()</span></div>

<div class="viewcode-block" id="StatisticCalculator.printList"><a class="viewcode-back" href="../../../api/resistics.calculators.statisticCalculator.html#resistics.calculators.statisticCalculator.StatisticCalculator.printList">[docs]</a>    <span class="k">def</span> <span class="nf">printList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Class information as a list of strings</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : list</span>
<span class="sd">            List of strings with information</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">textLst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Default options&quot;</span><span class="p">)</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Input Chans = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">listToString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getInChans</span><span class="p">())))</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Output Chans = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">listToString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getOutChans</span><span class="p">())))</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Remote Chans = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">listToString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRemoteChans</span><span class="p">()))</span>
        <span class="p">)</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Powers = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">listToString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPSDChans</span><span class="p">())))</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Coherence pairs = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">listToString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCohPairs</span><span class="p">()))</span>
        <span class="p">)</span>
        <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Partial coherence = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">listToString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPolDirs</span><span class="p">()))</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEvalFreq</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Evaluation frequencies = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">textLst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;Evaluation frequencies = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arrayToString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEvalFreq</span><span class="p">()))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">textLst</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Neeraj Shah

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>